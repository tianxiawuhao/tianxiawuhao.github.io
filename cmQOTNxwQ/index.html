<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>目标检测常见算法 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="目标检测常见算法 | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="目标检测常见算法" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/cmQOTNxwQ/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/lxd_7NXjJ/" class="tag">cv</a>
                
                <a href="https://tianxiawuhao.github.io/PjnFH7MKT/" class="tag">机器学习</a>
                
              </span>
              <h1>目标检测常见算法</h1>
              <span class="meta">
                Posted on
                2024-06-06，22 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/cmQOTNxwQ.jpeg" alt="封面图">
          </img>
          
          <h2 id="一-目标检测常见算法">一、目标检测常见算法</h2>
<p>object detection，就是在给定的图片中精确找到物体所在位置，并标注出物体的类别。所以，object detection要解决的问题就是物体在哪里以及是什么的整个流程问题。<br>
然而，这个问题可不是那么容易解决的，物体的尺寸变化范围很大，摆放物体的角度，姿态不定，而且可以出现在图片的任何地方，更何况物体还可以是多个类别。</p>
<h3 id="目标检测算法">目标检测算法</h3>
<p>目前学术和工业界出现的目标检测算法分成3类：</p>
<ol>
<li>
<p>传统的目标检测算法：<code>Cascade</code> + <code>HOG/DPM</code> + <code>Haar/SVM</code>以及上述方法的诸多改进、优化；</p>
</li>
<li>
<p>候选区域/窗 + 深度学习分类：通过提取候选区域，并对相应区域进行以深度学习方法为主的分类的方案，如：<br>
<code>R-CNN（Selective Search + CNN + SVM）</code><br>
<code>SPP-net（ROI Pooling）</code><br>
<code>Fast R-CNN（Selective Search + CNN + ROI）</code><br>
<code>Faster R-CNN（RPN + CNN + ROI）</code><br>
<code>R-FCN</code></p>
</li>
<li>
<p>基于深度学习的回归方法：<code>YOLO/SSD/DenseBox</code> 等方法；以及最近出现的结合<code>RNN</code>算法的<code>RRC detection</code>；结合<code>DPM</code>的<code>Deformable CNN</code>等</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://tianxiawuhao.github.io/post-images/20180502184712966" alt="" loading="lazy"></figure>
<h3 id="传统目标检测流程">传统目标检测流程：</h3>
<ul>
<li>
<p>区域选择（穷举策略：采用滑动窗口，且设置不同的大小，不同的长宽比对图像进行遍历，时间复杂度高）</p>
</li>
<li>
<p>特征提取（SIFT、HOG等；形态多样性、光照变化多样性、背景多样性使得特征鲁棒性差）</p>
</li>
<li>
<p>分类器分类（主要有SVM、<code>Adaboost</code>等）</p>
</li>
</ul>
<h2 id="二-传统的目标检测算法">二、传统的目标检测算法</h2>
<h3 id="从图像识别的任务说起">从图像识别的任务说起</h3>
<p>这里有一个图像任务：既要把图中的物体识别出来，又要用方框框出它的位置。</p>
<figure data-type="image" tabindex="2"><img src="https://tianxiawuhao.github.io/post-images/20180502184736909" alt="" loading="lazy"></figure>
<p>这个任务本质上就是这两个问题：</p>
<ul>
<li>
<p>图像识别，</p>
</li>
<li>
<p>定位。</p>
</li>
</ul>
<p><strong>图像识别（classification）</strong>：<br>
输入：图片<br>
输出：物体的类别<br>
评估方法：准确率</p>
<figure data-type="image" tabindex="3"><img src="https://tianxiawuhao.github.io/post-images/20180502184748897" alt="" loading="lazy"></figure>
<p><strong>定位（localization）</strong>：<br>
输入：图片<br>
输出：方框在图片中的位置（x,y,w,h）<br>
评估方法：检测评价函数 intersection-over-union</p>
<figure data-type="image" tabindex="4"><img src="https://tianxiawuhao.github.io/post-images/20180502184759516" alt="" loading="lazy"></figure>
<p>卷积神经网络CNN已经帮我们完成了图像识别（判定是猫还是狗）的任务了，我们只需要添加一些额外的功能来完成定位任务即可。</p>
<h3 id="定位的问题的解决思路">定位的问题的解决思路</h3>
<ul>
<li>
<p>思路一：看做回归问题<br>
看做回归问题，我们需要预测出（x,y,w,h）四个参数的值，从而得出方框的位置。</p>
<figure data-type="image" tabindex="5"><img src="https://tianxiawuhao.github.io/post-images/20180502184813752" alt="" loading="lazy"></figure>
<p><strong>步骤1:</strong><br>
　　• 先解决简单问题， 搭一个识别图像的神经网络<br>
　　• 在<code>AlexNet VGG GoogleLenet</code>上微调fine-tuning一下</p>
<figure data-type="image" tabindex="6"><img src="https://tianxiawuhao.github.io/post-images/20180502184825843" alt="" loading="lazy"></figure>
<p><strong>步骤2:</strong><br>
　　• 在上述神经网络的尾部展开（也就说CNN前面保持不变，我们对CNN的结尾处作出改进：加了两个头：“分类头”和“回归头”）<br>
　　• 成为classification + regression模式</p>
<figure data-type="image" tabindex="7"><img src="https://tianxiawuhao.github.io/post-images/20180502184835184" alt="" loading="lazy"></figure>
<p><strong>步骤3:</strong><br>
　　• Regression那个部分用欧氏距离损失<br>
　　• 使用SGD训练</p>
<p><strong>步骤4:</strong><br>
　　• 预测阶段把2个头部拼上<br>
　　• 完成不同的功能</p>
<p>这里需要进行两次fine-tuning<br>
第一次在<code>ALexNet</code>上做，第二次将头部改成regression head，前面不变，做一次fine-tuning</p>
<p><strong>Regression的部分加在哪？</strong><br>
有两种处理方法：<br>
　　• 加在最后一个卷积层后面（如VGG）<br>
　　• 加在最后一个全连接层后面（如R-CNN）</p>
<p>regression太难做了，应想方设法转换为classification问题。<br>
regression的训练参数收敛的时间要长得多，所以上面的网络采取了用classification的网络来计算出网络共同部分的连接权值。</p>
</li>
</ul>
<p><strong>思路二：取图像窗口</strong><br>
　　• 还是刚才的classification + regression思路<br>
　　• 咱们取不同的大小的“框”<br>
　　• 让框出现在不同的位置，得出这个框的判定得分<br>
　　• 取得分最高的那个框</p>
<p>左上角的黑框：得分0.5</p>
<figure data-type="image" tabindex="8"><img src="https://tianxiawuhao.github.io/post-images/20180502184846534" alt="" loading="lazy"></figure>
<p>右上角的黑框：得分0.75</p>
<figure data-type="image" tabindex="9"><img src="https://tianxiawuhao.github.io/post-images/20180502184855431" alt="" loading="lazy"></figure>
<p>左下角的黑框：得分0.6</p>
<figure data-type="image" tabindex="10"><img src="https://tianxiawuhao.github.io/post-images/20180502184903855" alt="" loading="lazy"></figure>
<p>右下角的黑框：得分0.8</p>
<figure data-type="image" tabindex="11"><img src="https://tianxiawuhao.github.io/post-images/20180502184918638" alt="" loading="lazy"></figure>
<p>根据得分的高低，我们选择了右下角的黑框作为目标位置的预测。<br>
注：有的时候也会选择得分最高的两个框，然后取两框的交集作为最终的位置预测。</p>
<p><strong>疑惑：框要取多大？</strong><br>
取不同的框，依次从左上角扫到右下角。非常粗暴啊。</p>
<p>总结一下思路：<br>
对一张图片，用各种大小的框（遍历整张图片）将图片截取出来，输入到CNN，然后CNN会输出这个框的得分（classification）以及这个框图片对应的x,y,h,w（regression）。</p>
<figure data-type="image" tabindex="12"><img src="https://tianxiawuhao.github.io/post-images/20180502184927783" alt="" loading="lazy"></figure>
<p>这方法实在太耗时间了，做个优化。<br>
原来网络是这样的：</p>
<figure data-type="image" tabindex="13"><img src="https://tianxiawuhao.github.io/post-images/20180502184934479" alt="" loading="lazy"></figure>
<p>优化成这样：把全连接层改为卷积层，这样可以提提速。</p>
<figure data-type="image" tabindex="14"><img src="https://tianxiawuhao.github.io/post-images/2018050218494248" alt="" loading="lazy"></figure>
<h3 id="物体检测object-detection">物体检测（Object Detection）</h3>
<p>当图像有很多物体怎么办的？难度可是一下暴增啊。</p>
<p>那任务就变成了：多物体识别+定位多个物体<br>
那把这个任务看做分类问题？</p>
<figure data-type="image" tabindex="15"><img src="https://tianxiawuhao.github.io/post-images/2018050218495175" alt="" loading="lazy"></figure>
<p>看成分类问题有何不妥？<br>
　　• 你需要找很多位置， 给很多个不同大小的框<br>
　　• 你还需要对框内的图像分类<br>
　　• 当然， 如果你的GPU很强大， 恩， 那加油做吧…</p>
<p>所以，传统目标检测的主要问题是：</p>
<ul>
<li>
<p>基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余</p>
</li>
<li>
<p>手工设计的特征对于多样性的变化没有很好的鲁棒性</p>
</li>
</ul>
<p>看做classification， 有没有办法优化下？我可不想试那么多框那么多位置啊！</p>
<h3 id="候选区域窗-深度学习分类">候选区域/窗 + 深度学习分类</h3>
<h4 id="r-cnn横空出世">R-CNN横空出世</h4>
<p>有人想到一个好方法：预先找出图中目标可能出现的位置，即候选区域（Region Proposal）。利用图像中的纹理、边缘、颜色等信息，可以保证在选取较少窗口(几千甚至几百）的情况下保持较高的召回率（Recall）。</p>
<p>所以，问题就转变成找出可能含有物体的区域/框（也就是候选区域/框，比如选2000个候选框），这些框之间是可以互相重叠互相包含的，这样我们就可以避免暴力枚举的所有框了。</p>
<figure data-type="image" tabindex="16"><img src="https://tianxiawuhao.github.io/post-images/20180502185002616" alt="" loading="lazy"></figure>
<p>大牛们发明好多选定候选框Region Proposal的方法，比如<code>Selective Search</code>和<code>EdgeBoxes</code>。那提取候选框用到的算法“选择性搜索”到底怎么选出这些候选框的呢？具体可以看一下<code>PAMI2015</code>的<code>“What makes for effective detection proposals？”</code></p>
<p>以下是各种选定候选框的方法的性能对比。</p>
<figure data-type="image" tabindex="17"><img src="https://tianxiawuhao.github.io/post-images/20180502185009252" alt="" loading="lazy"></figure>
<p>有了候选区域，剩下的工作实际就是对候选区域进行图像分类的工作（特征提取+分类）。对于图像分类，不得不提的是2012年ImageNet大规模视觉识别挑战赛（ILSVRC）上，机器学习泰斗Geoffrey Hinton教授带领学生Krizhevsky使用卷积神经网络将ILSVRC分类任务的Top-5 error降低到了15.3%，而使用传统方法的第二名top-5 error高达 26.2%。此后，卷积神经网络CNN占据了图像分类任务的绝对统治地位。</p>
<p>2014年，RBG（Ross B. Girshick）使用Region Proposal + CNN代替传统目标检测使用的滑动窗口+手工设计特征，设计了R-CNN框架，使得目标检测取得巨大突破，并开启了基于深度学习目标检测的热潮。</p>
<figure data-type="image" tabindex="18"><img src="https://tianxiawuhao.github.io/post-images/20180502185016896" alt="" loading="lazy"></figure>
<p>R-CNN的简要步骤如下</p>
<ul>
<li>
<p>输入测试图像</p>
</li>
<li>
<p>利用选择性搜索Selective Search算法在图像中从下到上提取2000个左右的可能包含物体的候选区域Region Proposal</p>
</li>
<li>
<p>因为取出的区域大小各自不同，所以需要将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN，将CNN的fc7层的输出作为特征</p>
</li>
<li>
<p>将每个Region Proposal提取到的CNN特征输入到SVM进行分类</p>
</li>
</ul>
<p>具体步骤则如下<br>
步骤一：训练（或者下载）一个分类模型（比如AlexNet）</p>
<figure data-type="image" tabindex="19"><img src="https://tianxiawuhao.github.io/post-images/20180502185026282" alt="" loading="lazy"></figure>
<p>步骤二：对该模型做fine-tuning<br>
　　• 将分类数从1000改为20，比如20个物体类别 + 1个背景<br>
　　• 去掉最后一个全连接层</p>
<figure data-type="image" tabindex="20"><img src="https://tianxiawuhao.github.io/post-images/20180502185043292" alt="" loading="lazy"></figure>
<p>步骤三：特征提取<br>
　　• 提取图像的所有候选框（选择性搜索Selective Search）<br>
　　• 对于每一个区域：修正区域大小以适合CNN的输入，做一次前向运算，将第五个池化层的输出（就是对候选框提取到的特征）存到硬盘</p>
<figure data-type="image" tabindex="21"><img src="https://tianxiawuhao.github.io/post-images/20180502185055533" alt="" loading="lazy"></figure>
<p>步骤四：训练一个SVM分类器（二分类）来判断这个候选框里物体的类别<br>
每个类别对应一个SVM，判断是不是属于这个类别，是就是positive，反之nagative。</p>
<p>比如下图，就是狗分类的SVM</p>
<figure data-type="image" tabindex="22"><img src="https://tianxiawuhao.github.io/post-images/20180502185111157" alt="" loading="lazy"></figure>
<p>步骤五：使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。</p>
<figure data-type="image" tabindex="23"><img src="https://tianxiawuhao.github.io/post-images/20180502185124152" alt="" loading="lazy"></figure>
<p>细心的同学可能看出来了问题，R-CNN虽然不再像传统方法那样穷举，但R-CNN流程的第一步中对原始图片通过Selective Search提取的候选框region proposal多达2000个左右，而这2000个候选框每个框都需要进行CNN提特征+SVM分类，计算量很大，导致R-CNN检测速度很慢，一张图都需要47s。</p>
<figure data-type="image" tabindex="24"><img src="https://tianxiawuhao.github.io/post-images/20180502185132861" alt="" loading="lazy"></figure>
<p>有没有方法提速呢？答案是有的，这2000个region proposal不都是图像的一部分吗，那么我们完全可以对图像提一次卷积层特征，然后只需要将region proposal在原图的位置映射到卷积层特征图上，这样对于一张图像我们只需要提一次卷积层特征，然后将每个region proposal的卷积层特征输入到全连接层做后续操作。</p>
<p>但现在的问题是每个region proposal的尺度不一样，而全连接层输入必须是固定的长度，所以直接这样输入全连接层肯定是不行的。SPP Net恰好可以解决这个问题。</p>
<h4 id="spp-net">SPP Net</h4>
<p>SPP：Spatial Pyramid Pooling（空间金字塔池化）</p>
<p>SPP-Net是出自2015年发表在IEEE上的论文-《Spatial Pyramid Pooling in Deep ConvolutionalNetworks for Visual Recognition》。</p>
<p>众所周知，CNN一般都含有卷积部分和全连接部分，其中，卷积层不需要固定尺寸的图像，而全连接层是需要固定大小的输入。</p>
<figure data-type="image" tabindex="25"><img src="https://tianxiawuhao.github.io/post-images/20180502185139979" alt="" loading="lazy"></figure>
<p>所以当全连接层面对各种尺寸的输入数据时，就需要对输入数据进行crop（crop就是从一个大图扣出网络输入大小的patch，比如227×227），或warp（把一个边界框bounding box的内容resize成227×227）等一系列操作以统一图片的尺寸大小，比如224<em>224（ImageNet）、32</em>32(LenNet)、96*96等。</p>
<figure data-type="image" tabindex="26"><img src="https://tianxiawuhao.github.io/post-images/20180502185146716" alt="" loading="lazy"></figure>
<p>所以才如你在上文中看到的，在R-CNN中，“因为取出的区域大小各自不同，所以需要将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN”。</p>
<p>但warp/crop这种预处理，导致的问题要么被拉伸变形、要么物体不全，限制了识别精确度。没太明白？说句人话就是，一张16:9比例的图片你硬是要Resize成1:1的图片，你说图片失真不？</p>
<p>SPP Net的作者Kaiming He等人逆向思考，既然由于全连接FC层的存在，普通的CNN需要通过固定输入图片的大小来使得全连接层的输入固定。那借鉴卷积层可以适应任何尺寸，为何不能在卷积层的最后加入某种结构，使得后面全连接层得到的输入变成固定的呢？</p>
<p>这个“化腐朽为神奇”的结构就是spatial pyramid pooling layer。下图便是R-CNN和SPP Net检测流程的比较：</p>
<figure data-type="image" tabindex="27"><img src="https://tianxiawuhao.github.io/post-images/20180502185153417" alt="" loading="lazy"></figure>
<p><strong>它的特点有两个</strong>:</p>
<ul>
<li>
<p>结合空间金字塔方法实现CNNs的多尺度输入。<br>
SPP Net的第一个贡献就是在最后一个卷积层后，接入了金字塔池化层，保证传到下一层全连接层的输入固定。<br>
换句话说，在普通的CNN机构中，输入图像的尺寸往往是固定的（比如224*224像素），输出则是一个固定维数的向量。SPP Net在普通的CNN结构中加入了ROI池化层（ROI Pooling），使得网络的输入图像可以是任意尺寸的，输出则不变，同样是一个固定维数的向量。</p>
<p>简言之，CNN原本只能固定输入、固定输出，CNN加上SSP之后，便能任意输入、固定输出。神奇吧？</p>
<p>ROI池化层一般跟在卷积层后面，此时网络的输入可以是任意尺度的，在SPP layer中每一个pooling的filter会根据输入调整大小，而SPP的输出则是固定维数的向量，然后给到全连接FC层。</p>
<figure data-type="image" tabindex="28"><img src="https://tianxiawuhao.github.io/post-images/20180502185205233" alt="" loading="lazy"></figure>
</li>
<li>
<p>只对原图提取一次卷积特征<br>
在R-CNN中，每个候选框先resize到统一大小，然后分别作为CNN的输入，这样是很低效的。<br>
而SPP Net根据这个缺点做了优化：只对原图进行一次卷积计算，便得到整张图的卷积特征feature map，然后找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层，完成特征提取工作。</p>
<p>如此这般，R-CNN要对每个区域计算卷积，而SPPNet只需要计算一次卷积，从而节省了大量的计算时间，比R-CNN有一百倍左右的提速。</p>
<figure data-type="image" tabindex="29"><img src="https://tianxiawuhao.github.io/post-images/20180502185214362" alt="" loading="lazy"></figure>
</li>
</ul>
<h4 id="fast-r-cnn">Fast R-CNN</h4>
<p>SPP Net真是个好方法，R-CNN的进阶版Fast R-CNN就是在R-CNN的基础上采纳了SPP Net方法，对R-CNN作了改进，使得性能进一步提高。</p>
<p><strong>R-CNN与Fast R-CNN的区别有哪些呢？</strong><br>
先说R-CNN的缺点：即使使用了Selective Search等预处理步骤来提取潜在的bounding box作为输入，但是R-CNN仍会有严重的速度瓶颈，原因也很明显，就是计算机对所有region进行特征提取时会有重复计算，Fast-RCNN正是为了解决这个问题诞生的。</p>
<figure data-type="image" tabindex="30"><img src="https://tianxiawuhao.github.io/post-images/20180502185224548" alt="" loading="lazy"></figure>
<p>与R-CNN框架图对比，可以发现主要有两处不同：一是最后一个卷积层后加了一个ROI pooling layer，二是损失函数使用了多任务损失函数(multi-task loss)，将边框回归Bounding Box Regression直接加入到CNN网络中训练</p>
<ul>
<li>
<p>ROI pooling layer实际上是SPP-NET的一个精简版，SPP-NET对每个proposal使用了不同大小的金字塔映射，而ROI pooling layer只需要下采样到一个7x7的特征图。对于VGG16网络conv5_3有512个特征图，这样所有region proposal对应了一个7<em>7</em>512维度的特征向量作为全连接层的输入。</p>
<p>换言之，这个网络层可以把不同大小的输入映射到一个固定尺度的特征向量，而我们知道，conv、pooling、relu等操作都不需要固定size的输入，因此，在原始图片上执行这些操作后，虽然输入图片size不同导致得到的feature map尺寸也不同，不能直接接到一个全连接层进行分类，但是可以加入这个神奇的ROI Pooling层，对每个region都提取一个固定维度的特征表示，再通过正常的softmax进行类型识别。</p>
</li>
<li>
<p>R-CNN训练过程分为了三个阶段，而Fast R-CNN直接使用softmax替代SVM分类，同时利用多任务损失函数边框回归也加入到了网络中，这样整个的训练过程是端到端的(除去Region Proposal提取阶段)。</p>
<p>也就是说，之前R-CNN的处理流程是先提proposal，然后CNN提取特征，之后用SVM分类器，最后再做bbox regression，而在Fast R-CNN中，作者巧妙的把bbox regression放进了神经网络内部，与region分类和并成为了一个multi-task模型，实际实验也证明，这两个任务能够共享卷积特征，并相互促进。</p>
</li>
</ul>
<figure data-type="image" tabindex="31"><img src="https://tianxiawuhao.github.io/post-images/20180502185247910" alt="" loading="lazy"></figure>
<p>所以，Fast-RCNN很重要的一个贡献是成功的让人们看到了Region Proposal + CNN这一框架实时检测的希望，原来多类检测真的可以在保证准确率的同时提升处理速度，也为后来的Faster R-CNN做下了铺垫。</p>
<p><strong>画一画重点</strong>：<br>
R-CNN有一些相当大的缺点（把这些缺点都改掉了，就成了Fast R-CNN）。</p>
<p>大缺点：由于每一个候选框都要独自经过CNN，这使得花费的时间非常多。<br>
解决：共享卷积层，现在不是每一个候选框都当做输入进入CNN了，而是输入一张完整的图片，在第五个卷积层再得到每个候选框的特征</p>
<p>原来的方法：许多候选框（比如两千个）--&gt;CNN--&gt;得到每个候选框的特征--&gt;分类+回归<br>
现在的方法：一张完整图片--&gt;CNN--&gt;得到每张候选框的特征--&gt;分类+回归</p>
<p>所以容易看见，Fast R-CNN相对于R-CNN的提速原因就在于：不过不像R-CNN把每个候选区域给深度网络提特征，而是整张图提一次特征，再把候选框映射到conv5上，而SPP只需要计算一次特征，剩下的只需要在conv5层上操作就可以了。</p>
<p>在性能上提升也是相当明显的：</p>
<figure data-type="image" tabindex="32"><img src="https://tianxiawuhao.github.io/post-images/20180502185258775" alt="" loading="lazy"></figure>
<h4 id="faster-r-cnn">Faster R-CNN</h4>
<p>Fast R-CNN存在的问题：存在瓶颈：选择性搜索，找出所有的候选框，这个也非常耗时。那我们能不能找出一个更加高效的方法来求出这些候选框呢？</p>
<p>解决：加入一个提取边缘的神经网络，也就说找到候选框的工作也交给神经网络来做了。</p>
<p>所以，rgbd在Fast R-CNN中引入Region Proposal Network(RPN)替代Selective Search，同时引入anchor box应对目标形状的变化问题（anchor就是位置和大小固定的box，可以理解成事先设置好的固定的proposal）。</p>
<p>具体做法：<br>
　　• 将RPN放在最后一个卷积层的后面<br>
　　• RPN直接训练得到候选区域</p>
<figure data-type="image" tabindex="33"><img src="https://tianxiawuhao.github.io/post-images/20180502185307597" alt="" loading="lazy"></figure>
<p>RPN简介：<br>
　　• 在feature map上滑动窗口<br>
　　• 建一个神经网络用于物体分类+框位置的回归<br>
　　• 滑动窗口的位置提供了物体的大体位置信息<br>
　　• 框的回归提供了框更精确的位置</p>
<figure data-type="image" tabindex="34"><img src="https://tianxiawuhao.github.io/post-images/20180502185320200" alt="" loading="lazy"></figure>
<p>一种网络，四个损失函数;<br>
　　• RPN calssification(anchor good.bad)<br>
　　• RPN regression(anchor-&gt;propoasal)<br>
　　• Fast R-CNN classification(over classes)<br>
　　• Fast R-CNN regression(proposal -&gt;box)</p>
<figure data-type="image" tabindex="35"><img src="https://tianxiawuhao.github.io/post-images/20180502185332506" alt="" loading="lazy"></figure>
<h4 id="速度对比">速度对比</h4>
<figure data-type="image" tabindex="36"><img src="https://tianxiawuhao.github.io/post-images/2018050218534282" alt="" loading="lazy"></figure>
<p>Faster R-CNN的主要贡献就是设计了提取候选区域的网络RPN，代替了费时的选择性搜索selective search，使得检测速度大幅提高。</p>
<p>最后总结一下各大算法的步骤：</p>
<blockquote>
<p>RCNN<br>
1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)<br>
2.每个候选框内图像块缩放至相同大小，并输入到CNN内进行特征提取<br>
3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>
4.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
<p>Fast R-CNN<br>
1.在图像中确定约1000-2000个候选框 (使用选择性搜索Selective Search)<br>
2.对整张图片输进CNN，得到feature map<br>
3.找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层<br>
4.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>
5.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
<p>Faster R-CNN<br>
1.对整张图片输进CNN，得到feature map<br>
2.卷积特征输入到RPN，得到候选框的特征信息<br>
3.对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>
4.对于属于某一类别的候选框，用回归器进一步调整其位置</p>
</blockquote>
<figure data-type="image" tabindex="37"><img src="https://tianxiawuhao.github.io/post-images/20180507114358700" alt="" loading="lazy"></figure>
<p>简言之，即如本文开头所列</p>
<blockquote>
<p>R-CNN（Selective Search + CNN + SVM）<br>
SPP-net（ROI Pooling）<br>
Fast R-CNN（Selective Search + CNN + ROI）<br>
Faster R-CNN（RPN + CNN + ROI）</p>
</blockquote>
<p>总的来说，从R-CNN, SPP-NET, Fast R-CNN, Faster R-CNN一路走来，基于深度学习目标检测的流程变得越来越精简，精度越来越高，速度也越来越快。可以说基于Region Proposal的R-CNN系列目标检测方法是当前目标检测技术领域最主要的一个分支。</p>
<h2 id="三-基于深度学习的回归方法">三、基于深度学习的回归方法</h2>
<h3 id="yolo-cvpr2016-oral">YOLO (CVPR2016, oral)</h3>
<blockquote>
<p>(You Only Look Once: Unified, Real-Time Object Detection)</p>
</blockquote>
<p>Faster R-CNN的方法目前是主流的目标检测方法，但是速度上并不能满足实时的要求。YOLO一类的方法慢慢显现出其重要性，这类方法使用了回归的思想，利用整张图作为网络的输入，直接在图像的多个位置上回归出这个位置的目标边框，以及目标所属的类别。</p>
<p>我们直接看上面YOLO的目标检测的流程图：</p>
<figure data-type="image" tabindex="38"><img src="https://tianxiawuhao.github.io/post-images/20180502185352726" alt="" loading="lazy"></figure>
<p>(1) 给个一个输入图像，首先将图像划分成7<em>7的网格<br>
(2) 对于每个网格，我们都预测2个边框（包括每个边框是目标的置信度以及每个边框区域在多个类别上的概率）<br>
(3) 根据上一步可以预测出7</em>7*2个目标窗口，然后根据阈值去除可能性比较低的目标窗口，最后NMS去除冗余窗口即可</p>
<p>可以看到整个过程非常简单，不再需要中间的Region Proposal找目标，直接回归便完成了位置和类别的判定。</p>
<figure data-type="image" tabindex="39"><img src="https://tianxiawuhao.github.io/post-images/20180502185400428" alt="" loading="lazy"></figure>
<p>小结：YOLO将目标检测任务转换成一个回归问题，大大加快了检测的速度，使得YOLO可以每秒处理45张图像。而且由于每个网络预测目标窗口时使用的是全图信息，使得false positive比例大幅降低（充分的上下文信息）。</p>
<p>但是YOLO也存在问题：没有了Region Proposal机制，只使用7*7的网格回归会使得目标不能非常精准的定位，这也导致了YOLO的检测精度并不是很高。</p>
<h3 id="ssd">SSD</h3>
<blockquote>
<p>(SSD: Single Shot MultiBox Detector)</p>
</blockquote>
<p>上面分析了YOLO存在的问题，使用整图特征在7*7的粗糙网格内回归对目标的定位并不是很精准。那是不是可以结合Region Proposal的思想实现精准一些的定位？SSD结合YOLO的回归思想以及Faster R-CNN的anchor机制做到了这点。</p>
<figure data-type="image" tabindex="40"><img src="https://tianxiawuhao.github.io/post-images/20180502185410188" alt="" loading="lazy"></figure>
<p>上图是SSD的一个框架图，首先SSD获取目标位置和类别的方法跟YOLO一样，都是使用回归，但是YOLO预测某个位置使用的是全图的特征，SSD预测某个位置使用的是这个位置周围的特征（感觉更合理一些）。</p>
<p>那么如何建立某个位置和其特征的对应关系呢？可能你已经想到了，使用Faster R-CNN的anchor机制。如SSD的框架图所示，假如某一层特征图(图b)大小是8<em>8，那么就使用3</em>3的滑窗提取每个位置的特征，然后这个特征回归得到目标的坐标信息和类别信息(图c)。</p>
<p>不同于Faster R-CNN，这个anchor是在多个feature map上，这样可以利用多层的特征并且自然的达到多尺度（不同层的feature map 3*3滑窗感受野不同）。</p>
<p><strong>小结：SSD结合了YOLO中的回归思想和Faster R-CNN中的anchor机制，使用全图各个位置的多尺度区域特征进行回归，既保持了YOLO速度快的特性，也保证了窗口预测的跟Faster R-CNN一样比较精准。SSD在VOC2007上mAP可以达到72.1%，速度在GPU上达到58帧每秒。</strong></p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95">一、目标检测常见算法</a>
<ul>
<li><a href="#%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95">目标检测算法</a></li>
<li><a href="#%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B">传统目标检测流程：</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95">二、传统的目标检测算法</a>
<ul>
<li><a href="#%E4%BB%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%AF%B4%E8%B5%B7">从图像识别的任务说起</a></li>
<li><a href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">定位的问题的解决思路</a></li>
<li><a href="#%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8Bobject-detection">物体检测（Object Detection）</a></li>
<li><a href="#%E5%80%99%E9%80%89%E5%8C%BA%E5%9F%9F%E7%AA%97-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB">候选区域/窗 + 深度学习分类</a>
<ul>
<li><a href="#r-cnn%E6%A8%AA%E7%A9%BA%E5%87%BA%E4%B8%96">R-CNN横空出世</a></li>
<li><a href="#spp-net">SPP Net</a></li>
<li><a href="#fast-r-cnn">Fast R-CNN</a></li>
<li><a href="#faster-r-cnn">Faster R-CNN</a></li>
<li><a href="#%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94">速度对比</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%9E%E5%BD%92%E6%96%B9%E6%B3%95">三、基于深度学习的回归方法</a>
<ul>
<li><a href="#yolo-cvpr2016-oral">YOLO (CVPR2016, oral)</a></li>
<li><a href="#ssd">SSD</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/_MxFmWNQI/">
                <span class="post-title">
                  jenkins自定义环境镜像&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/BO3Wz58QH/">
              <span class="post-title">
                多体动力学&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>