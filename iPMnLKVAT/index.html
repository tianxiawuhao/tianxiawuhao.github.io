<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>CompletableFuture | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="CompletableFuture | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="CompletableFuture" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/iPMnLKVAT/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/6l4aXFMiY/" class="tag">java</a>
                
              </span>
              <h1>CompletableFuture</h1>
              <span class="meta">
                Posted on
                2023-10-23，19 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/iPMnLKVAT.png" alt="封面图">
          </img>
          
          <h2 id="前言">前言</h2>
<p>CompletableFuture继承于java.util.concurrent.Future，它本身具备Future的所有特性，并且基于JDK1.8的流式编程以及Lambda表达式等实现一元操作符、异步性以及事件驱动编程模型，可以用来实现多线程的串行关系，并行关系，聚合关系。它的灵活性和更强大的功能是Future无法比拟的。</p>
<h2 id="一-创建方式">一、创建方式</h2>
<h3 id="1-用默认线程池">1. 用默认线程池</h3>
<p><code>CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();</code></p>
<p>默认使用 ForkJoinPool.commonPool()，commonPool是一个会被很多任务 共享 的线程池，比如同一 JVM 上的所有 CompletableFuture、并行 Stream 都将共享 commonPool，commonPool 设计时的目标场景是运行 非阻塞的 CPU 密集型任务，为最大化利用 CPU，其线程数默认为 CPU 数量 - 1。</p>
<h3 id="2-用自定义线程池">2. 用自定义线程池</h3>
<pre><code class="language-java">ThreadPoolExecutor pool = new ThreadPoolExecutor(2, 4, 3,
                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3),
                new ThreadPoolExecutor.DiscardOldestPolicy());
CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hello World!&quot;), pool);
</code></pre>
<h2 id="二-使用示例">二、使用示例</h2>
<h3 id="1-构建异步任务">1. 构建异步任务</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>runAsync</td>
<td>无</td>
<td>进行数据处理，接收前一步骤传递的数据，无返回值。</td>
</tr>
<tr>
<td>supplyAsync</td>
<td>有</td>
<td>进行数据处理，接收前一步骤传递的数据，处理加工后返回。返回数据类型可以和前一步骤返回的数据类型不同。</td>
</tr>
</tbody>
</table>
<h4 id="1runasync">（1）runAsync</h4>
<pre><code class="language-java">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {
        return asyncRunStage(asyncPool, runnable);
    }
</code></pre>
<p>示例</p>
<pre><code class="language-java">public static void runAsync() {
    //使用默认线程池
    CompletableFuture cf = CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hello World!&quot;));
    assertFalse(cf.isDone());    
    //使用自定义线程池
    CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Hello World!&quot;),                                                 Executors.newSingleThreadExecutor());
    }
</code></pre>
<h4 id="2supplyasync">（2）supplyAsync</h4>
<pre><code class="language-java">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
    return asyncSupplyStage(asyncPool, supplier);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">public static void supplyAsync() throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; f = CompletableFuture.supplyAsync(() -&gt; {
            try {
                //ForkJoinPool.commonPool-worker-1线程
                System.out.println(Thread.currentThread().getName());
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;hello&quot;;
        });
        //阻塞等待3秒 
        String result = f.get();
        //main线程
        System.out.println(Thread.currentThread().getName());
        System.out.println(result);
}
</code></pre>
<h3 id="2-单任务结果消费">2. 单任务结果消费</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thenApply</td>
<td>有</td>
<td>在前一个阶段上应用thenApply函数，将上一阶段完成的结果作为当前阶段的入参</td>
</tr>
<tr>
<td>thenAccept</td>
<td>无返回值</td>
<td>消费前一阶段的结果</td>
</tr>
<tr>
<td>thenRun</td>
<td>无返回值，并且无入参</td>
<td>当上一阶段完成后，执行本阶段的任务</td>
</tr>
</tbody>
</table>
<h4 id="1thenapply">（1）thenApply</h4>
<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(
    Function&lt;? super T,? extends U&gt; fn) {
    return uniApplyStage(asyncPool, fn);
}
</code></pre>
<p>示例</p>
<pre><code class="language-csharp">csharp复制代码public static void thenApply() throws ExecutionException, InterruptedException {
    CompletableFuture cf = CompletableFuture.completedFuture(&quot;message&quot;).thenApplyAsync(s -&gt; {
        System.out.println(s);
        return s.toUpperCase();
    }).thenApply(s-&gt;{
        System.out.println(s);
        return s + &quot;:body&quot;;
    });
    System.out.println(cf.get());
}
</code></pre>
<p><code>then</code>意味着这个阶段的动作发生当前的阶段正常完成之后。本例中，当前节点完成，返回字符串<code>message</code>。</p>
<p><code>Apply</code>意味着返回的阶段将会对结果前一阶段的结果应用一个函数。</p>
<p>函数的执行会被<strong>阻塞</strong></p>
<h4 id="2thenaccept">（2）thenAccept</h4>
<pre><code class="language-scss">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
    return asyncSupplyStage(asyncPool, supplier);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">public static void thenAccept() throws InterruptedException {
    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        return &quot;message&quot;;
    }).thenAccept((consumer) -&gt; {
        System.out.println(consumer);
    });
}
</code></pre>
<h4 id="3thenrun">（3）thenRun</h4>
<pre><code class="language-java">public CompletableFuture&lt;Void&gt; thenRun(Runnable action) {
    return uniRunStage(null, action);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">public static void thenRun() throws InterruptedException {
    CompletableFuture.supplyAsync(() -&gt; {
        //执行异步任务
        System.out.println(&quot;执行任务&quot;);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;success&quot;;
    }).thenRun(() -&gt; {
        // Computation Finished.
        System.out.println(&quot;上一阶段任务执行完成&quot;);
    });
    Thread.sleep(2000);
}
</code></pre>
<h3 id="3-合并结果消费">3. 合并结果消费</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thenCombine</td>
<td>有</td>
<td>合并另外一个任务，两个任务都完成后，执行BiFunction，入参为两个任务结果，返回新结果</td>
</tr>
<tr>
<td>thenAcceptBoth</td>
<td>无</td>
<td>合并另外一个任务，两个任务都完成后，执行这个方法等待第一个阶段的完成(大写转换)， 它的结果传给一个指定的返回CompletableFuture函数，它的结果就是返回的CompletableFuture的结果，入参为两个任务结果，不返回新结果</td>
</tr>
<tr>
<td>runAfterBoth</td>
<td>无返回值无入参</td>
<td>合并另外一个任务，两个任务都完成后，执行Runnable，注意，这里的两个任务是同时执行</td>
</tr>
</tbody>
</table>
<h4 id="1thencombine">（1）thenCombine</h4>
<p>如果CompletableFuture依赖两个前面阶段的结果， 它复合两个阶段的结果再返回一个结果，我们就可以使用<code>thenCombine()</code>函数。整个流水线是同步的。</p>
<pre><code class="language-java">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,
                             BiFunction&lt;? super T,? super U,? extends V&gt; fn) {
    return biApplyStage(null, other, fn);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">public static void thenCombine() {
    CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; {
        System.out.println(&quot;processing a...&quot;);
        return &quot;hello&quot;;
    });
    CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; {
        System.out.println(&quot;processing b...&quot;);
        return &quot; world&quot;;
    });
    CompletableFuture&lt;String&gt; cfC = CompletableFuture.supplyAsync(() -&gt; {
        System.out.println(&quot;processing c...&quot;);
        return &quot;, I'm CodingTao!&quot;;
    });
    cfA.thenCombine(cfB, (resultA, resultB) -&gt; {
        System.out.println(resultA + resultB);  // hello world
        return resultA + resultB;
    }).thenCombine(cfC, (resultAB, resultC) -&gt; {
        System.out.println(resultAB + resultC); // hello world, I'm CodingTao!
        return resultAB + resultC;
    });
}
</code></pre>
<h4 id="2thenacceptboth">（2）thenAcceptBoth</h4>
<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,
                          BiConsumer&lt;? super T, ? super U&gt; action) {
    return biAcceptStage(null, other, action);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">private static void thenAcceptBoth() {
    CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;);
    CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; &quot;resultB&quot;);
    cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; {
        //resultA,resultB
        System.out.println(resultA+&quot;,&quot;+resultB);
    });
}
</code></pre>
<h4 id="3runafterboth">（3）runAfterBoth</h4>
<pre><code class="language-java">public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,
                                            Runnable action) {
    return biRunStage(null, other, action);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">private static void runAfterBoth() {
    CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;process a&quot;);
        return &quot;resultA&quot;;
    });
    CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;process b&quot;);
        return &quot;resultB&quot;;
    });
    cfB.runAfterBoth(cfA, () -&gt; {
        //resultA,resultB
        System.out.println(&quot;任务A和任务B同时完成&quot;);
    });
    try {
        Thread.sleep(6000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h3 id="4-任一结果消费">4. 任一结果消费</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>applyToEither</td>
<td>有</td>
<td>其中任一任务完成后，执行Function，结果转换，入参为已完成的任务结果。返回新结果，要求两个任务结果为同一类型</td>
</tr>
<tr>
<td>acceptEither</td>
<td>无</td>
<td>其中任一任务完成后，执行Consumer，消费结果，入参为已完成的任务结果。不返回新结果，要求两个任务结果为同一类型</td>
</tr>
<tr>
<td>runAfterEither</td>
<td>无返回值无入参</td>
<td>其中任一任务完成后，执行Runnable，消费结果，无入参。不返回新结果，不要求两个任务结果为同一类型</td>
</tr>
</tbody>
</table>
<p>场景</p>
<p>假设查询商品a，有两种方式，A和B，但是A和B的执行速度不一样，希望哪个先返回就用那个的返回值。</p>
<h4 id="1applytoeither">（1）applyToEither</h4>
<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other,                                                  Function&lt;? super T, U&gt; fn) {
    return orApplyStage(null, other, fn);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">private static void applyToEither() throws ExecutionException, InterruptedException {
    CompletableFuture&lt;String&gt; futureA = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;通过方式A获取商品a&quot;;
    });
    CompletableFuture&lt;String&gt; futureB = CompletableFuture.supplyAsync(() -&gt; {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;通过方式B获取商品a&quot;;
    });
    CompletableFuture&lt;String&gt; futureC = futureA.applyToEither(futureB, product -&gt; &quot;结果:&quot; + product);
    //结果:通过方式A获取商品a
    System.out.println(futureC.get());
}
</code></pre>
<h4 id="2accepteither">（2）acceptEither</h4>
<h4 id="3runaftereither">（3）runAfterEither</h4>
<h3 id="5-级联任务">5. 级联任务</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thenCompose</td>
<td>有</td>
<td>当原任务完成后，以其结果为参数，返回一个新的任务（而不是新结果，类似flatMap）</td>
</tr>
</tbody>
</table>
<h4 id="1thencompose">（1）thenCompose</h4>
<p>这个方法等待第一个阶段的完成(大写转换)， 它的结果传给一个指定的返回CompletableFuture函数，它的结果就是返回的CompletableFuture的结果。</p>
<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(
    Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) {
    return uniComposeStage(null, fn);
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">private static void thenCompose() {
    String original = &quot;Message&quot;;
    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))
            .thenCompose(upper -&gt; CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s))
                    .thenApply(s -&gt; upper + s));
    // MESSAGEmessage
    System.out.println(cf.join());
}
</code></pre>
<h3 id="6-单任务结果或异常消费">6. 单任务结果或异常消费</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>有无返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle</td>
<td>有</td>
<td>任务完成后执行BiFunction，结果转换，入参为结果或者异常，返回新结果</td>
</tr>
<tr>
<td>whenComplete</td>
<td>无</td>
<td>任务完成后执行BiConsumer，结果消费，入参为结果或者异常，不返回新结果</td>
</tr>
<tr>
<td>exceptionally</td>
<td>无</td>
<td>任务异常，则执行Function，异常转换，入参为原任务的异常信息，若原任务无异常，则返回原任务结果，即不执行转换</td>
</tr>
</tbody>
</table>
<p>异常流程</p>
<pre><code class="language-java">CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;)
              .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)
              .thenApply(resultB -&gt; resultB + &quot; resultC&quot;)
              .thenApply(resultC -&gt; resultC + &quot; resultD&quot;);
</code></pre>
<p>上面的代码中，任务 A、B、C、D 依次执行，如果任务 A 抛出异常（当然上面的代码不会抛出异常），那么后面的任务都得不到执行。如果任务 C 抛出异常，那么任务 D 得不到执行。</p>
<p>那么我们怎么处理异常呢？看下面的代码，我们在任务 A 中抛出异常，并对其进行处理：</p>
<h4 id="1handle">（1）handle</h4>
<p>示例</p>
<pre><code class="language-java">private static void handle() {
    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;resultA&quot;)
            .thenApply(resultA -&gt; resultA + &quot; resultB&quot;)
            // 任务 C 抛出异常
            .thenApply(resultB -&gt; {throw new RuntimeException();})
            // 处理任务 C 的返回值或异常
            .handle(new BiFunction&lt;Object, Throwable, Object&gt;() {
                @Override
                public Object apply(Object re, Throwable throwable) {
                    if (throwable != null) {
                        return &quot;errorResultC&quot;;
                    }
                    return re;
                }
            })
            .thenApply(resultC -&gt; {
                System.out.println(&quot;resultC:&quot; + resultC);
                return resultC + &quot; resultD&quot;;
            });
    System.out.println(future.join());
}
</code></pre>
<h4 id="2whencomplete">（2）whenComplete</h4>
<p>示例</p>
<pre><code class="language-java">private static void whenComplete() throws ExecutionException, InterruptedException {
    // 创建异步执行任务:
    CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;{
        System.out.println(Thread.currentThread()+&quot;job1 start,time-&gt;&quot;+System.currentTimeMillis());
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
        if(true){
            throw new RuntimeException(&quot;test&quot;);
        }else{
            System.out.println(Thread.currentThread()+&quot;job1 exit,time-&gt;&quot;+System.currentTimeMillis());
            return 1.2;
        }
    });
    //cf执行完成后会将执行结果和执行过程中抛出的异常传入回调方法
    // 如果是正常执行，a=1.2，b则传入的异常为null
    //如果异常执行，a=null，b则传入异常信息
    CompletableFuture&lt;Double&gt; cf2=cf.whenComplete((a,b)-&gt;{
        System.out.println(Thread.currentThread()+&quot;job2 start,time-&gt;&quot;+System.currentTimeMillis());
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
        if(b!=null){
            System.out.println(&quot;error stack trace-&gt;&quot;);
            b.printStackTrace();
        }else{
            System.out.println(&quot;run succ,result-&gt;&quot;+a);
        }
        System.out.println(Thread.currentThread()+&quot;job2 exit,time-&gt;&quot;+System.currentTimeMillis());
    });
    //等待子任务执行完成
    System.out.println(&quot;main thread start wait,time-&gt;&quot;+System.currentTimeMillis());
    //如果cf是正常执行的，cf2.get的结果就是cf执行的结果
    //如果cf是执行异常，则cf2.get会抛出异常
    System.out.println(&quot;run result-&gt;&quot;+cf2.get());
    System.out.println(&quot;main thread exit,time-&gt;&quot;+System.currentTimeMillis());
}
</code></pre>
<h4 id="3exceptionally">（3）exceptionally</h4>
<h3 id="7-合并多个complete为一个">7. 合并多个complete为一个</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>allOf</td>
<td></td>
<td>合并多个complete为一个，等待全部完成</td>
</tr>
<tr>
<td>anyOf</td>
<td></td>
<td>合并多个complete为一个，等待其中之一完成</td>
</tr>
</tbody>
</table>
<h4 id="1allof">（1）allOf</h4>
<p>我们在处理业务时，有时会有多任务异步处理，同步返回结果的情况</p>
<ul>
<li>采用多线程执异步行某种任务，比如在不同主机查询磁盘列表信息。</li>
<li>将执行结果搜集，分组分类，处理。</li>
<li>将处理以后的结果给予展示。</li>
</ul>
<p>示例</p>
<pre><code class="language-java"> // 创建异步执行任务:
        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;{
            System.out.println(Thread.currentThread()+&quot; start job1,time-&gt;&quot;+System.currentTimeMillis());
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
            }
            System.out.println(Thread.currentThread()+&quot; exit job1,time-&gt;&quot;+System.currentTimeMillis());
            return 1.2;
        });
        CompletableFuture&lt;Double&gt; cf2 = CompletableFuture.supplyAsync(()-&gt;{
            System.out.println(Thread.currentThread()+&quot; start job2,time-&gt;&quot;+System.currentTimeMillis());
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
            }
            System.out.println(Thread.currentThread()+&quot; exit job2,time-&gt;&quot;+System.currentTimeMillis());
            return 3.2;
        });
        CompletableFuture&lt;Double&gt; cf3 = CompletableFuture.supplyAsync(()-&gt;{
            System.out.println(Thread.currentThread()+&quot; start job3,time-&gt;&quot;+System.currentTimeMillis());
            try {
                Thread.sleep(1300);
            } catch (InterruptedException e) {
            }
//            throw new RuntimeException(&quot;test&quot;);
            System.out.println(Thread.currentThread()+&quot; exit job3,time-&gt;&quot;+System.currentTimeMillis());
            return 2.2;
        });
        //allof等待所有任务执行完成才执行cf4，如果有一个任务异常终止，则cf4.get时会抛出异常，都是正常执行，cf4.get返回null
        //anyOf是只有一个任务执行完成，无论是正常执行或者执行异常，都会执行cf4，cf4.get的结果就是已执行完成的任务的执行结果
        CompletableFuture cf4=CompletableFuture.allOf(cf,cf2,cf3).whenComplete((a,b)-&gt;{
            if(b!=null){
                System.out.println(&quot;error stack trace-&gt;&quot;);
                b.printStackTrace();
            }else{
                System.out.println(&quot;run succ,result-&gt;&quot;+a);
            }
        });
        System.out.println(&quot;main thread start cf4.get(),time-&gt;&quot;+System.currentTimeMillis());
        //等待子任务执行完成
        System.out.println(&quot;cf4 run result-&gt;&quot;+cf4.get());
        System.out.println(&quot;main thread exit,time-&gt;&quot;+System.currentTimeMillis());
</code></pre>
<p>获取返回值方法</p>
<pre><code class="language-java">public &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; allOf(List&lt;CompletableFuture&lt;T&gt;&gt; futuresList) {
    CompletableFuture&lt;Void&gt; allFuturesResult =
            CompletableFuture.allOf(futuresList.toArray(new CompletableFuture[futuresList.size()]));
    return allFuturesResult.thenApply(v -&gt;
            futuresList.stream().
                    map(future -&gt; future.join()).
                    collect(Collectors.&lt;T&gt;toList())
    );
}
</code></pre>
<h4 id="2anyof">（2）anyOf</h4>
<p>CompletableFuture.anyOf()和其名字介绍的一样，当任何一个CompletableFuture完成的时候【相同的结果类型】，返回一个新的CompletableFuture。</p>
<p>示例</p>
<pre><code class="language-java">private static void anyOf() throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            return &quot;Result of Future 1&quot;;
        });

        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            return &quot;Result of Future 2&quot;;
        });

        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            return &quot;Result of Future 3&quot;;
        });
        CompletableFuture&lt;Object&gt; anyOfFuture = CompletableFuture.anyOf(future1, future2, future3);
        System.out.println(anyOfFuture.get()); // Result of Future 2
    }
</code></pre>
<h2 id="三-其他相关api">三、其他相关api</h2>
<h3 id="1-future接口">1. future接口</h3>
<h4 id="1isdone">（1）isDone()</h4>
<p>判断任务是否完成。三种完成情况：normally（正常执行完毕）、exceptionally（执行异常）、via cancellation（取消）</p>
<h4 id="2get">（2）get()</h4>
<p>阻塞获取结果或抛出受检测异常，需要显示进行try...catch处理。</p>
<h4 id="3getlong-timeouttimeunit-unit">（3）get(long timeout,TimeUnit unit)</h4>
<p>超时阻塞获取结果</p>
<h4 id="4cancelboolean-mayinterruptifrunning">（4）cancel(boolean mayInterruptIfRunning)</h4>
<p>取消任务，若一个任务未完成，则以CancellationException异常。其相关未完成的子任务也会以CompletionException结束</p>
<h4 id="5iscancelled">（5）isCancelled()</h4>
<p>是否已取消，在任务正常执行完成前取消，才为true。否则为false。</p>
<h3 id="2-completablefuture接口">2. CompletableFuture接口</h3>
<h4 id="1join">（1）join</h4>
<p>​        阻塞获取结果或抛出非受检异常。</p>
<h4 id="2getnowt-valueifabsent">（2）getNow(T valueIfAbsent)</h4>
<p>​        若当前任务无结果，则返回valueIfAbsent，否则返回已完成任务的结果。</p>
<h4 id="3completet-value">（3）complete(T value)</h4>
<p>​        设置任务结果，任务正常结束，之后的任务状态为已完成。</p>
<h4 id="4completeexceptionallythrowable-ex">（4）completeExceptionally(Throwable ex)</h4>
<p>​        设置任务异常结果，任务异常结束，之后的任务状态为已完成。</p>
<h4 id="5iscompletedexceptionally">（5）isCompletedExceptionally()</h4>
<p>​        判断任务是否异常结束。异常可能的原因有：取消、显示设置任务异常结果、任务动作执行异常等。</p>
<h4 id="6getnumberofdependents">（6）getNumberOfDependents()</h4>
<p>​        返回依赖当前任务的任务数量，主要用于监控。</p>
<h4 id="7ortimeoutlong-timeouttimeunit-unit-jdk9">（7）orTimeout(long timeout,TimeUnit unit) jdk9</h4>
<p>​        设置任务完成超时时间，若在指定时间内未正常完成，则任务会以异常(TimeoutException)结束。</p>
<h4 id="8completeontimeoutt-valuelong-timeouttimeunit-unit-jdk9">（8）completeOnTimeout(T value,long timeout,TimeUnit unit) jdk9</h4>
<p>​        设置任务完成超时时间，若在指定时间内未正常完成，则以给定的value为任务结果</p>
<h2 id="四-实战">四、实战</h2>
<h3 id="1-api网关做接口的聚合">1. API网关做接口的聚合</h3>
<pre><code class="language-java">//这两个参数从外部获得
Long userId = 10006L;
String orderId = &quot;XXXXXXXXXXXXXXXXXXXXXX&quot;;
//从用户服务获取用户信息
UserInfo userInfo = userService.getUserInfo(userId);
//从用订单务获取订单信息
OrderInfo orderInfo = orderService.getOrderInfo(orderId);
//返回两者的聚合DTO
return new OrderDetailDTO(userInfo,orderInfo);
</code></pre>
<p>​        下面三个外部接口的信息一定是不相关联的，也就是可以并行获取，三个接口的结果都获取完毕之后做一次数据聚合到DTO即可，也就是聚合的耗时大致是这三个接口中耗时最长的接口的响应时间</p>
<pre><code class="language-java">@Service
public class OrderDetailService {
	/**
	 * 建立一个线程池专门交给CompletableFuture使用
	 */
	private final ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 20, 0, TimeUnit.SECONDS,
			new ArrayBlockingQueue&lt;&gt;(100));
	@Autowired
	private UserService userService;
	@Autowired
	private OrderService orderService;
	public OrderDetailDTO getOrderDetail(Long userId, String orderId) throws Exception {
		CompletableFuture&lt;UserInfo&gt; userInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; userService.getUserInfo(userId), executor);
		CompletableFuture&lt;OrderInfo&gt; orderInfoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; orderService.getOrderInfo(orderId), executor);
		CompletableFuture&lt;OrderDetailDTO&gt; result
				= userInfoCompletableFuture.thenCombineAsync(orderInfoCompletableFuture, OrderDetailDTO::new, executor);
		return result.get();
	}
}
</code></pre>
<h2 id="五-区别">五、区别</h2>
<h4 id="1whencomplete和handle区别">（1）whenComplete和handle区别</h4>
<p><code>whenComplete</code> 与 <code>handle</code> 方法就类似于 <code>try..catch..finanlly</code> 中 <code>finally</code> 代码块。无论是否发生异常，都将会执行的。这两个方法区别在于 <code>handle</code> 支持返回结果。</p>
<h4 id="2thenapply与thencompose的异同">（2）thenApply与thenCompose的异同</h4>
<p>​		对于thenApply，fn函数是一个对一个已完成的stage或者说CompletableFuture的的返回值进行计算、操作；</p>
<p>​		对于thenCompose，fn函数是对另一个CompletableFuture进行计算、操作。</p>
<h4 id="3有无async的区别">（3）有无Async的区别</h4>
<p>没有Async的在CompleteableFuture调用它的线程定义的线程上运行，因此通常不知道在哪里执行该线程。如果结果已经可用，它可能会立即执行。</p>
<p>​     有Async的无论环境如何，都在环境定义的执行程序上运行。为此CompletableFuture通常ForkJoinPool.commonPool()。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F">一、创建方式</a>
<ul>
<li><a href="#1-%E7%94%A8%E9%BB%98%E8%AE%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0">1. 用默认线程池</a></li>
<li><a href="#2-%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0">2. 用自定义线程池</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">二、使用示例</a>
<ul>
<li><a href="#1-%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">1. 构建异步任务</a>
<ul>
<li><a href="#1runasync">（1）runAsync</a></li>
<li><a href="#2supplyasync">（2）supplyAsync</a></li>
</ul>
</li>
<li><a href="#2-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C%E6%B6%88%E8%B4%B9">2. 单任务结果消费</a>
<ul>
<li><a href="#1thenapply">（1）thenApply</a></li>
<li><a href="#2thenaccept">（2）thenAccept</a></li>
<li><a href="#3thenrun">（3）thenRun</a></li>
</ul>
</li>
<li><a href="#3-%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C%E6%B6%88%E8%B4%B9">3. 合并结果消费</a>
<ul>
<li><a href="#1thencombine">（1）thenCombine</a></li>
<li><a href="#2thenacceptboth">（2）thenAcceptBoth</a></li>
<li><a href="#3runafterboth">（3）runAfterBoth</a></li>
</ul>
</li>
<li><a href="#4-%E4%BB%BB%E4%B8%80%E7%BB%93%E6%9E%9C%E6%B6%88%E8%B4%B9">4. 任一结果消费</a>
<ul>
<li><a href="#1applytoeither">（1）applyToEither</a></li>
<li><a href="#2accepteither">（2）acceptEither</a></li>
<li><a href="#3runaftereither">（3）runAfterEither</a></li>
</ul>
</li>
<li><a href="#5-%E7%BA%A7%E8%81%94%E4%BB%BB%E5%8A%A1">5. 级联任务</a>
<ul>
<li><a href="#1thencompose">（1）thenCompose</a></li>
</ul>
</li>
<li><a href="#6-%E5%8D%95%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C%E6%88%96%E5%BC%82%E5%B8%B8%E6%B6%88%E8%B4%B9">6. 单任务结果或异常消费</a>
<ul>
<li><a href="#1handle">（1）handle</a></li>
<li><a href="#2whencomplete">（2）whenComplete</a></li>
<li><a href="#3exceptionally">（3）exceptionally</a></li>
</ul>
</li>
<li><a href="#7-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcomplete%E4%B8%BA%E4%B8%80%E4%B8%AA">7. 合并多个complete为一个</a>
<ul>
<li><a href="#1allof">（1）allOf</a></li>
<li><a href="#2anyof">（2）anyOf</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3api">三、其他相关api</a>
<ul>
<li><a href="#1-future%E6%8E%A5%E5%8F%A3">1. future接口</a>
<ul>
<li><a href="#1isdone">（1）isDone()</a></li>
<li><a href="#2get">（2）get()</a></li>
<li><a href="#3getlong-timeouttimeunit-unit">（3）get(long timeout,TimeUnit unit)</a></li>
<li><a href="#4cancelboolean-mayinterruptifrunning">（4）cancel(boolean mayInterruptIfRunning)</a></li>
<li><a href="#5iscancelled">（5）isCancelled()</a></li>
</ul>
</li>
<li><a href="#2-completablefuture%E6%8E%A5%E5%8F%A3">2. CompletableFuture接口</a>
<ul>
<li><a href="#1join">（1）join</a></li>
<li><a href="#2getnowt-valueifabsent">（2）getNow(T valueIfAbsent)</a></li>
<li><a href="#3completet-value">（3）complete(T value)</a></li>
<li><a href="#4completeexceptionallythrowable-ex">（4）completeExceptionally(Throwable ex)</a></li>
<li><a href="#5iscompletedexceptionally">（5）isCompletedExceptionally()</a></li>
<li><a href="#6getnumberofdependents">（6）getNumberOfDependents()</a></li>
<li><a href="#7ortimeoutlong-timeouttimeunit-unit-jdk9">（7）orTimeout(long timeout,TimeUnit unit) jdk9</a></li>
<li><a href="#8completeontimeoutt-valuelong-timeouttimeunit-unit-jdk9">（8）completeOnTimeout(T value,long timeout,TimeUnit unit) jdk9</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E5%AE%9E%E6%88%98">四、实战</a>
<ul>
<li><a href="#1-api%E7%BD%91%E5%85%B3%E5%81%9A%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%81%9A%E5%90%88">1. API网关做接口的聚合</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E5%8C%BA%E5%88%AB">五、区别</a><br>
*
<ul>
<li><a href="#1whencomplete%E5%92%8Chandle%E5%8C%BA%E5%88%AB">（1）whenComplete和handle区别</a></li>
<li><a href="#2thenapply%E4%B8%8Ethencompose%E7%9A%84%E5%BC%82%E5%90%8C">（2）thenApply与thenCompose的异同</a></li>
<li><a href="#3%E6%9C%89%E6%97%A0async%E7%9A%84%E5%8C%BA%E5%88%AB">（3）有无Async的区别</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/qvR3ZWwD8/">
                <span class="post-title">
                  Docker overlay2磁盘占用过高&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/z-YRElc0W/">
              <span class="post-title">
                Go基础-类型断言 Type Assertion&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>