<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>PostgreSQL概述二 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="PostgreSQL概述二 | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="PostgreSQL概述二" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/IKbaKSlgE/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/WebMb8vrq/" class="tag">postgreSql</a>
                
              </span>
              <h1>PostgreSQL概述二</h1>
              <span class="meta">
                Posted on
                2023-04-10，25 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/IKbaKSlgE.png" alt="封面图">
          </img>
          
          <h2 id="七-数据类型">七、数据类型</h2>
<p>PGSQL支持的类型特别丰富，大多数的类型和MySQL都有对应的关系</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>对比MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔类型</td>
<td>boolean，标准的布尔类型，只能存储true，false</td>
<td>MySQL中虽然没有对应的boolean，但是有替换的类型，数值的tinyint类型，和PGSQL的boolean都是占1个字节。</td>
</tr>
<tr>
<td>整型</td>
<td>smallint（2字节），integer（4字节），bigint（8字节）</td>
<td>跟MySQL没啥区别。</td>
</tr>
<tr>
<td>浮点型</td>
<td>decimal，numeric（和decimal一样一样的，精准浮点型），real（float），double precision（double），money（货币类型）</td>
<td>和MySQL基本也没区别，MySQL支持float，double，decimal。MySQL没有这个货币类型。</td>
</tr>
<tr>
<td>字符串类型</td>
<td>varchar(n)（character varying），char(n)（character），text</td>
<td>这里和MySQL基本没区别。PGSQL存储的varchar类型，可以存储一个G。MySQL好像存储64kb（应该是）。</td>
</tr>
<tr>
<td>日期类型</td>
<td>date（年月日），time（时分秒），timestamp（年月日时分秒）（time和timestamp可以设置时区）</td>
<td>没啥说的，和MySQL基本没区别。MySQL有个datetime。</td>
</tr>
<tr>
<td>二进制类型</td>
<td>bytea-存储二进制类型</td>
<td>MySQL也支持，MySQL中是blob</td>
</tr>
<tr>
<td>位图类型</td>
<td>bit(n)（定长位图），bit varying(n)（可变长度位图）</td>
<td>就是存储0，1。MySQL也有，只是这个类型用的不多。</td>
</tr>
<tr>
<td>枚举类型</td>
<td>enum，跟Java的enum一样</td>
<td>MySQL也支持。</td>
</tr>
<tr>
<td>几何类型</td>
<td>点，直线，线段，圆…………</td>
<td>MySQL没有，但是一般开发也用不到</td>
</tr>
<tr>
<td>数组类型</td>
<td>在类型后，追加[]，代表存储数组</td>
<td>MySQL没有~~~</td>
</tr>
<tr>
<td>JSON类型</td>
<td>json（存储JSON数据的文本），jsonb（存储JSON二进制）</td>
<td>可以存储JSON，MySQL8.x也支持</td>
</tr>
<tr>
<td>ip类型</td>
<td>cidr（存储ip地址）</td>
<td>MySQL也不支持~</td>
</tr>
</tbody>
</table>
<h2 id="八-postgresql基本操作数据类型">八、PostgreSQL基本操作&amp;数据类型</h2>
<h3 id="81-单引号和双引号">8.1 单引号和双引号</h3>
<p>在PGSQL中，写SQL语句时，单引号用来标识实际的值。双引号用来标识一个关键字，比如表名，字段名。</p>
<pre><code>-- 单引号写具体的值，双引号类似MySQL的``标记，用来填充关键字
-- 下面的葡萄牙会报错，因为葡萄牙不是关键字
select 1.414,'卡塔尔',&quot;葡萄牙&quot;;
</code></pre>
<h3 id="82-数据类型转换">8.2 数据类型转换</h3>
<p>第一种方式：只需要在值的前面，添加上具体的数据类型即可</p>
<pre><code class="language-sql">-- 将字符串转成位图类型
select bit '010101010101001';
</code></pre>
<p>第二种方式：也可以在具体值的后面，添加上 ::类型 ，来指定</p>
<pre><code class="language-sql">-- 数据类型
select '2011-11-11'::date;
select '101010101001'::bit(20);
select '13'::int;
</code></pre>
<p>第三种方式：使用CAST函数</p>
<pre><code class="language-sql">-- 类型转换的完整写法
select CAST(varchar '100' as int);
</code></pre>
<p>8.3 布尔类型<br>
布尔类型简单的丫批，可以存储三个值，true，false，null</p>
<pre><code class="language-sql">-- 布尔类型的约束没有那么强，true，false大小写随意，他会给你转，同时yes，no这种他也认识，但是需要转换
select true,false,'yes'::boolean,boolean 'no',True,FaLse,NULL::boolean;
</code></pre>
<p>boolean类型在做and和or的逻辑操作时，结果</p>
<table>
<thead>
<tr>
<th>字段A</th>
<th>字段B</th>
<th>a and b</th>
<th>a or b</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>NULL</td>
<td>NULL</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>NULL</td>
<td>false</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<h3 id="84-数值类型">8.4 数值类型</h3>
<h4 id="841-整型">8.4.1 整型</h4>
<p>整型比较简单，主要就是三个：</p>
<ul>
<li>
<p>smallint、int2：2字节</p>
</li>
<li>
<p>integer、int、int4：4字节</p>
</li>
<li>
<p>bigint、int8：8字节</p>
</li>
</ul>
<p>正常没啥事就integer，如果要存主键，比如雪花算法，那就bigint。空间要节约，根据情况smallint</p>
<h4 id="842-浮点型">8.4.2 浮点型</h4>
<p>浮点类型就关注2个（其实是一个）</p>
<ul>
<li>
<p>decimal(n,m)：本质就是numeric，PGSQL会帮你转换</p>
</li>
<li>
<p>numeric(n,m)：PGSQL本质的浮点类型</p>
</li>
</ul>
<p>针对浮点类型的数据，就使用 numeric</p>
<h4 id="843-序列">8.4.3 序列</h4>
<p>MySQL中的主键自增，是基于auto_increment去实现。MySQL里没有序列的对象。</p>
<p>PGSQL和Oracle十分相似，支持序列：sequence。</p>
<p>PGSQL可没有auto_increment。</p>
<p>序列的正常构建方式：</p>
<pre><code class="language-sql">create sequence laozheng.table_id_seq;
-- 查询下一个值
select nextval('laozheng.table_id_seq');
-- 查询当前值
select currval('laozheng.table_id_seq');
</code></pre>
<p>默认情况下，seqeunce的起始值是0，每次nextval递增1，最大值9223372036854775807</p>
<p>告诉缓存，插入的数据比较多，可以指定告诉缓存，一次性计算出20个后续的值，nextval时，就不可以不去计算，直接去高速缓存拿值，效率会有一内内的提升。</p>
<p>序列大多数的应用，是用作表的主键自增效果。</p>
<pre><code class="language-sql">-- 表自增
create table laozheng.xxx(
    id int8 default nextval('laozheng.table_id_seq'),
    name varchar(16)
);
insert into laozheng.xxx (name) values ('xxx');
select * from laozheng.xxx;
</code></pre>
<p>上面这种写法没有问题，但是很不爽~很麻烦。</p>
<p>PGSQL提供了序列的数据类型，可以在声明表结构时，直接指定序列的类型即可。</p>
<p>bigserial相当于给bigint类型设置了序列实现自增。</p>
<ul>
<li>
<p>smallserial</p>
</li>
<li>
<p>serial</p>
</li>
<li>
<p>bigserial</p>
</li>
</ul>
<pre><code class="language-sql">-- 表自增（爽）
create table laozheng.yyy(
    id bigserial,   
    name varchar(16)
);
insert into laozheng.yyy (name) values ('yyy');
</code></pre>
<p>在drop表之后，序列不会被删除，但是序列会变为不可用的状态。<br>
因为序列在使用serial去构建时，会绑定到指定表的指定列上。</p>
<p>如果是单独构建序列，再构建表，使用传统方式实现，序列和表就是相对独立的。</p>
<h4 id="844-数值的常见操作">8.4.4 数值的常见操作</h4>
<p>针对数值咱们可以实现加减乘除取余这5个操作</p>
<p>还有其他的操作方式</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>幂</td>
<td>2 ^ 3</td>
<td>8</td>
</tr>
<tr>
<td>|/</td>
<td>平方根</td>
<td>|/ 36</td>
<td>6</td>
</tr>
<tr>
<td>@</td>
<td>绝对值</td>
<td>@ -5</td>
<td>5</td>
</tr>
<tr>
<td>&amp;</td>
<td>与</td>
<td>31 &amp; 16</td>
<td>16</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
<td>31|32</td>
<td>63</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>1&lt;&lt;1</td>
<td>2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>16&gt;&gt;1</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>数值操作也提供了一些函数，比如pi()，round(数值，位数)，floor()，ceil()</p>
<h3 id="85-字符串类型">8.5 字符串类型</h3>
<p>字符串类型用的是最多的一种，在PGSQL里，主要支持三种：</p>
<ul>
<li>
<p>character（就是MySQL的char类型），定长字符串。（最大可以存储1G）</p>
</li>
<li>
<p>character varying（varchar），可变长度的字符串。（最大可以存储1G）</p>
</li>
<li>
<p>text（跟MySQL异常）长度特别长的字符串。</p>
</li>
</ul>
<p>操作没什么说的，但是字符串常见的函数特别多。</p>
<p>字符串的拼接一要要使用||来拼接。</p>
<p>其他的函数，可以查看 http://www.postgres.cn/docs/12/functions-string.html</p>
<h3 id="86-日期类型">8.6 日期类型</h3>
<p>在PGSQL中，核心的时间类型，就三个。</p>
<ul>
<li>
<p>timestamp（时间戳，覆盖 年月日时分秒）</p>
</li>
<li>
<p>date（年月日）</p>
</li>
<li>
<p>time（时分秒）</p>
</li>
</ul>
<p>在PGSQL中，声明时间的方式。</p>
<p>只需要使用字符串正常的编写 yyyy-MM-dd HH:mm:ss 就可以转换为时间类型。</p>
<p>直接在字符串位置使用之前讲到的数据类型转换就可以了。</p>
<p>当前系统时间 ：</p>
<ul>
<li>
<p>可以使用now作为当前系统时间（没有时区的概念）</p>
<pre><code class="language-sql">select timestamp 'now';
-- 直接查询now，没有时区的概念
select time with time zone 'now' at time zone '08:00:00'
</code></pre>
</li>
<li>
<p>也可以使用current_timestamp的方式获取（推荐，默认东八区）</p>
</li>
</ul>
<p><strong>日期类型的运算</strong></p>
<ul>
<li>
<p>正常对date类型做+，-操作，默认单位就是天~</p>
</li>
<li>
<p>date + time = timestamp~~~</p>
<pre><code class="language-sql">select date '2011-11-11' + time '12:12:12' ;
</code></pre>
</li>
<li>
<p>可以针对timestamp使用interval的方式进行 +，-操作，在查询以时间范围为条件的内容时，可以使用</p>
<pre><code class="language-sql">select timestamp '2011-11-11 12:12:12' + interval '1day' + interval '1minute' + interval '1month';
</code></pre>
</li>
</ul>
<h3 id="87-枚举类型">8.7 枚举类型</h3>
<p>枚举类型MySQL也支持，只是没怎么用，PGSQL同样支持这种数据类型</p>
<p>可以声明枚举类型作为表中的字段类型，这样可以无形的给表字段追加诡异的规范。</p>
<pre><code class="language-sql">-- 声明一个星期的枚举，值自然只有周一~周日。
create type week as enum ('Mon','Tues','Sun');
-- 声明一张表，表中的某个字段的类型是上面声明的枚举。
drop table test;
create table test(
    id bigserial ,
    weekday week
);
insert into test (weekday) values ('Mon');
insert into test (weekday) values ('Fri');
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://tianxiawuhao.github.io/post-images/c985fea909096b65f763502fe87d4a15.png" alt="" loading="lazy"></figure>
<h3 id="88-ip类型">8.8 IP类型</h3>
<p>PGSQL支持IP类型的存储，支持IPv4，IPv6这种，甚至Mac这种诡异类型也支持</p>
<p>这种IP类型，可以在存储IP时，帮助做校验，其次也可以针对IP做范围查找。</p>
<p>IP校验的效果</p>
<figure data-type="image" tabindex="2"><img src="https://tianxiawuhao.github.io/post-images/df39f560480c10d7611fddf085815cf8.png" alt="" loading="lazy"></figure>
<p>IP也支持范围查找。</p>
<figure data-type="image" tabindex="3"><img src="https://tianxiawuhao.github.io/post-images/7eef2ba8a96cbe462d1f0e5be3a7dbbb.png" alt="" loading="lazy"></figure>
<h3 id="89-jsonjsonb类型">8.9 JSON&amp;JSONB类型</h3>
<p>JSON在MySQL8.x中也做了支持，但是MySQL支持的不好，因为JSON类型做查询时，基本无法给JSON字段做索引。</p>
<p>PGSQL支持JSON类型以及JSONB类型。</p>
<p>JSON和JSONB的使用基本没区别。</p>
<p>撇去JSON类型，本质上JSON格式就是一个字符串，比如MySQL5.7不支持JSON的情况的下，使用text也可以，但是字符串类型无法校验JSON的格式，其次单独的字符串没有办法只获取JSON中某个key对应的value。</p>
<p><strong>JSON和JSONB的区别：</strong></p>
<ul>
<li>
<p>JSON类型无法构建索引，JSONB类型可以创建索引。</p>
</li>
<li>
<p>JSON类型的数据中多余的空格会被存储下来。JSONB会自动取消多余的空格。</p>
</li>
<li>
<p>JSON类型甚至可以存储重复的key，以最后一个为准。JSONB不会保留多余的重复key（保留最后一个）。</p>
</li>
<li>
<p>JSON会保留存储时key的顺序，JSONB不会保留原有顺序。</p>
</li>
</ul>
<p>JSON中key对应的value的数据类型</p>
<table>
<thead>
<tr>
<th>JSON</th>
<th>PGSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>text</td>
</tr>
<tr>
<td>number</td>
<td>numeric</td>
</tr>
<tr>
<td>boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>null</td>
<td>(none)</td>
</tr>
</tbody>
</table>
<pre><code>[
  {&quot;name&quot;: &quot;张三&quot;},
  {&quot;name&quot;: {
      &quot;info&quot;: &quot;xxx&quot;
    }}

]
</code></pre>
<p>操作JSON：</p>
<p>上述的四种JSON存储的类型：</p>
<pre><code class="language-sql">select '9'::JSON,'null'::JSON,'&quot;laozheng&quot;'::JSON,'true'::json;
select '9'::JSONB,'null'::JSONB,'&quot;laozheng&quot;'::JSONB,'true'::JSONB;
</code></pre>
<p>JSON数组</p>
<pre><code class="language-sql">select '[9,true,null,&quot;我是字符串&quot;]'::JSON;
</code></pre>
<p>JSON对象</p>
<figure data-type="image" tabindex="4"><img src="https://tianxiawuhao.github.io/post-images/48f4d49006d3aff3857a61ecf60e2541.png" alt="" loading="lazy"></figure>
<pre><code class="language-sql">select '{&quot;name&quot;: &quot;张三&quot;,&quot;age&quot;: 23,&quot;birthday&quot;: &quot;2011-11-11&quot;,&quot;gender&quot;: null}'::json;
select '{&quot;name&quot;: &quot;张三&quot;,&quot;age&quot;: 23,&quot;birthday&quot;: &quot;2011-11-11&quot;,&quot;gender&quot;: null}'::jsonb;
</code></pre>
<p>构建表存储JSON</p>
<pre><code class="language-sql">create table test(
    id bigserial,
    info json,
    infob jsonb
);
insert into
  test
(info,infob)   
  values 
('{&quot;name&quot;:            &quot;张三&quot;              ,&quot;age&quot;: 23,&quot;birthday&quot;: &quot;2011-11-11&quot;,&quot;gender&quot;: null}',
'{&quot;name&quot;:               &quot;张三&quot;             ,&quot;age&quot;: 23,&quot;birthday&quot;: &quot;2011-11-11&quot;,&quot;gender&quot;: null}')
select * from test;
</code></pre>
<p><img src="https://tianxiawuhao.github.io/post-images/81ae7fedfb06cba426e8edbccde41eba.png" alt="" loading="lazy"><br>
构建索引的效果</p>
<pre><code class="language-sql">create index json_index on test(info);
create index jsonb_index on test(infob);
</code></pre>
<p>JSON还支持很多函数。可以直接查看 http://www.postgres.cn/docs/12/functions-json.html 函数太多了，不分析了。</p>
<h3 id="810-复合类型">8.10 复合类型</h3>
<p>复合类型就好像Java中的一个对象，Java中有一个User，User和表做了一个映射，User中有个人信息对象。可以基于符合类型对映射上个人信息。</p>
<pre><code class="language-java">public class User{
   private Integer id;
   private Info info;
}

class Info{
   private String name;
   private Integer age;
}
</code></pre>
<p>按照上面的情况，将Info构建成一个复合类型</p>
<pre><code class="language-sql">-- 构建复合类型，映射上Info
create type info_type as (name varchar(32),age int);
-- 构建表，映射User
create table tb_user(
    id serial,
    info info_type
);
-- 添加数据
insert into tb_user (info) values (('张三',23));
insert into tb_user (info) values (('露丝',233));
insert into tb_user (info) values (('jack',33));
insert into tb_user (info) values (('李四',24));
select * from tb_user;
</code></pre>
<h3 id="811-数组类型">8.11 数组类型</h3>
<p>数组还是要依赖其他类型，比如在设置住址，住址可能有多个住址，可以采用数组类型去修饰字符串。</p>
<p>PGSQL中，指定数组的方式就是[]，可以指定一维数组，也支持二维甚至更多维数组。</p>
<p>构建数组的方式：</p>
<pre><code class="language-sql">drop table test;
create table test(
    id serial,
    col1 int[],
    col2 int[2],
    col3 int[][]
);
-- 构建表指定数组长度后，并不是说数组内容只有2的长度，可以插入更多数据
-- 甚至在你插入数据，如果将二维数组结构的数组扔到一维数组上，也可以存储。
-- 数组编写方式
select '{{how,are},{are,you}}'::varchar[];
select array[[1,2],[3,4]];
insert into test (col1,col2,col3) values ('{1,2,3}','{4,5,6}','{7,8,9}');
insert into test (col1,col2,col3) values ('{1,2,3}','{4,5,6}',array[[1,2],[3,4]]);
insert into test (col1,col2,col3) values ('{1,2,3}','{4,5,6}','{{1,2},{3,4}}');
select * from test;
</code></pre>
<p>如果现在要存储字符串数组，如果存储的数组中有双引号怎么办，有大括号怎么办。</p>
<pre><code class="language-sql">-- 如果存储的数组中的值，有单引号怎么办？
-- 使用两个单引号，作为一个单引号使用
select '{''how''}'::varchar[];
-- 如果存储的数组中的值，有逗号怎么办？(PGSQL中的数组索引从1开始算，写0也是从1开始算。)
-- 用双引号将数组的数据包起来~
select ('{&quot;how,are&quot;}'::varchar[])[2];
-- 如果存储的数组中的值，有双引号怎么办？
-- 如果要添加双引号，记得转义。
select ('{&quot;\&quot;how\&quot;,are&quot;}'::varchar[])[1];
</code></pre>
<p>数组的比较方式</p>
<pre><code>-- 包含
select array[1,2] @&gt; array[1];
-- 被包含
select array[1,2] &lt;@ array[1,2,4];
-- 是否有相同元素
select array[2,4,4,45,1] &amp;&amp; array[1];
</code></pre>
<h2 id="九-表">九、表</h2>
<p>表的构建语句，基本都会。</p>
<p>核心在于构建表时，要指定上一些约束。</p>
<h3 id="91-约束">9.1 约束</h3>
<p><strong>9.1.1 主键</strong><br>
-- 主键约束</p>
<pre><code class="language-sql">drop table test;
create table test(
    id bigserial primary key ,
    name varchar(32)
);
</code></pre>
<p><strong>9.1.2 非空</strong></p>
<pre><code class="language-sql">-- 非空约束
drop table test;
create table test(
    id bigserial primary key ,
    name varchar(32) not null
);
</code></pre>
<p><strong>9.1.3 唯一</strong></p>
<pre><code class="language-sql">drop table test;
create table test(
    id bigserial primary key ,
    name varchar(32) not null,
    id_card varchar(32) unique
);
insert into test (name,id_card) values ('张三','333333333333333333');
insert into test (name,id_card) values ('李四','333333333333333333');
insert into test (name,id_card) values (NULL,'433333333333333333');
</code></pre>
<p><strong>9.1.4 检查</strong></p>
<pre><code class="language-sql">-- 检查约束
-- 价格的表，price，discount_price
drop table test;
create table test(
    id bigserial primary key,
    name varchar(32) not null,
    price numeric check(price &gt; 0),
    discount_price numeric check(discount_price &gt; 0),
    check(price &gt;= discount_price)
);
insert into test (name,price,discount_price) values ('粽子',122,12);
</code></pre>
<p><strong>9.1.5 外键（不玩）</strong><br>
<strong>9.1.6 默认值</strong><br>
一般公司内，要求表中除了主键和业务字段之外，必须要有5个字段</p>
<blockquote>
<p>created，create_id，updated，update_id，is_delete</p>
</blockquote>
<p>-- 默认值</p>
<pre><code class="language-sql">create table test(
    id bigserial primary key,
    created timestamp default current_timestamp
);
</code></pre>
<h3 id="92-触发器">9.2 触发器</h3>
<p>触发器Trigger，是由事件出发的一种存储过程</p>
<p>当对标进行insert，update，delete，truncate操作时，会触发表的Trigger（看触发器的创建时指定的事件）</p>
<p>构建两张表，学生信息表，学生分数表。</p>
<p>在删除学生信息的同时，自动删除学生的分数。</p>
<p>先构建表信息，填充数据</p>
<pre><code class="language-sql">create table student(
    id int,
    name varchar(32)
);
create table score(
    id int,
    student_id int,
    math_score numeric,
    english_score numeric,
    chinese_score numeric
);
insert into student (id,name) values (1,'张三');
insert into student (id,name) values (2,'李四');
insert into
    score
(id,student_id,math_score,english_score,chinese_score)
    values
(1,1,66,66,66);

insert into
    score
(id,student_id,math_score,english_score,chinese_score)
    values
(2,2,55,55,55);

select * from student;
select * from score;
</code></pre>
<p>为了完成级联删除的操作，需要编写pl/sql。</p>
<p>先查看一下PGSQL支持的plsql，查看一下PGSQL的plsql语法</p>
<pre><code class="language-sql">[ &lt;&lt;label&gt;&gt; ]
[ DECLARE
    declarations ]
BEGIN
    statements
END [ label ];
</code></pre>
<p>构建一个存储函数，测试一下plsql</p>
<pre><code class="language-sql">-- 优先玩一下plsql
-- $$可以理解为是一种特殊的单引号，避免你在declare，begin，end中使用单引号时，出现问题，
-- 需要在编写后，在$$之后添加上当前内容的语言。
create function test() returns int as $$
declare
    money int := 10;
begin
    return money;
end;
$$ language plpgsql;

select test();
</code></pre>
<p>在简单了解了一下plpgsql的语法后，编写一个触发器函数。</p>
<p>触发器函数允许使用一些特殊变量</p>
<blockquote>
<p>NEW<br>
数据类型是RECORD；该变量为行级触发器中的INSERT/UPDATE操作保持新数据行。在语句级别的触发器以及DELETE操作，这个变量是null。</p>
<p>OLD<br>
数据类型是RECORD；该变量为行级触发器中的UPDATE/DELETE操作保持新数据行。在语句级别的触发器以及INSERT操作，这个变量是null。</p>
</blockquote>
<p>构建一个删除学生分数的触发器函数。</p>
<pre><code class="language-sql">-- 构建一个删除学生分数的触发器函数。
create function trigger_function_delete_student_score() returns trigger as $$
begin
    delete from score where student_id = old.id;
    return old;
end;
$$ language plpgsql;
</code></pre>
<p>开始构建触发器，在学生信息表删除时，执行前面声明的触发器函数</p>
<figure data-type="image" tabindex="5"><img src="https://tianxiawuhao.github.io/post-images/12cfc290064381cdc32ea97e070fa244.png" alt="" loading="lazy"></figure>
<pre><code class="language-sql">CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
    ON table_name
    [ FROM referenced_table_name ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] transition_relation_name } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( condition ) ]
    EXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )

where event can be one of:

    INSERT
    UPDATE [ OF column_name [, ... ] ]
    DELETE
    TRUNCATE

</code></pre>
<blockquote>
<p>当 CONSTRAINT选项被指定，这个命令会创建一个 约束触发器 。这和一个常规触发器相同，不过触发该触发器的时机可以使用SET CONSTRAINTS调整。约束触发器必须是表上的 AFTER ROW触发器。它们可以在导致触发器事件的语句末尾被引发或者在包含该语句的事务末尾被引发。在后一种情况中，它们被称作是被 延迟 。一个待处理的延迟触发器的引发也可以使用 SET CONSTRAINTS立即强制发生。当约束触发器实现的约束被违背时，约束触发器应该抛出一个异常。</p>
</blockquote>
<p>描绘一波~~</p>
<pre><code class="language-sql">-- 编写触发器，指定在删除某一行学生信息时，触发当前触发器，执行触发器函数
create trigger trigger_student 
after 
delete 
on student 
for each row 
execute function trigger_function_delete_student_score();
-- 测试效果
select * from student;
select * from score;
delete from student where id = 1;
</code></pre>
<h3 id="93-表空间问题填坑">9.3 表空间（问题填坑）</h3>
<p>在存储数据时，数据肯定要落到磁盘上，基于构建的tablespace，指定数据存放在磁盘上的物理地址。</p>
<p>如果没有自己设计tablespace，PGSQL会自动指定一个位置作为默认的存储点。</p>
<p>可以通过一个函数，查看表的物理数据存放在了哪个磁盘路径下。</p>
<pre><code>-- 查询表存储的物理地址
select pg_relation_filepath('student');
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://tianxiawuhao.github.io/post-images/d129cd9d2e32018a8ed69e1a7f1e23e0.png" alt="" loading="lazy"></figure>
<p>这个位置是在$PG_DATA后的存放地址</p>
<pre><code>$PG_DATA == /var/lib/pgsql/12/data/
</code></pre>
<p>41000其实就是存储数据的物理文件</p>
<p>构建表空间，指定数据存放位置</p>
<figure data-type="image" tabindex="7"><img src="https://tianxiawuhao.github.io/post-images/23e3020da19fb39ab114f81e2bee48d6.png" alt="" loading="lazy"></figure>
<pre><code class="language-sql">-- 构建表空间,构建表空间需要用户权限是超级管理员，其次需要指定的目录已经存在
create tablespace tp_test location '/var/lib/pgsql/12/tp_test';
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://tianxiawuhao.github.io/post-images/a8e4264e7cecf19cf1fe19eff60c7cfb.png" alt="" loading="lazy"></figure>
<p>构建数据库，以及表，指定到这个表空间中</p>
<figure data-type="image" tabindex="9"><img src="https://tianxiawuhao.github.io/post-images/59047e2440478c753563c6893d35f684.png" alt="" loading="lazy"></figure>
<p>其实指定表空间的存储位置后，PGSQL会在$PG_DATA目录下存储一份，同时在咱们构建tablespace时，指定的路径下也存储一份。</p>
<p>这两个绝对路径下的文件都有存储表中的数据信息。</p>
<pre><code>/var/lib/pgsql/12/data/pg_tblspc/41015/PG_12_201909212/41016/41020
/var/lib/pgsql/12/lz_tp_test/PG_12_201909212/41016/41020
</code></pre>
<p>进一步会发现，其实在PGSQL的默认目录下，存储的是一个link，连接文件，类似一个快捷方式</p>
<figure data-type="image" tabindex="10"><img src="https://tianxiawuhao.github.io/post-images/c5d057640598b98c0a75706343128eac.png" alt="" loading="lazy"></figure>
<p>9.4 视图<br>
跟MySQL的没啥区别，把一些复杂的操作封装起来，还可以隐藏一些敏感数据。</p>
<p>视图对于用户来说，就是一张真实的表，可以直接基于视图查询一张或者多张表的信息。</p>
<p>视图对于开发来说，就是一条SQL语句。</p>
<figure data-type="image" tabindex="11"><img src="https://tianxiawuhao.github.io/post-images/c909d0b2de396594fdf3135230774cac.png" alt="" loading="lazy"></figure>
<p>在PGSQL中，简单（单表）的视图是允许写操作的。</p>
<p>但是强烈不推荐对视图进行写操作，虽然PGSQL默认允许（简单的视图）。</p>
<p>写入的时候，其实修改的是表本身</p>
<pre><code class="language-sql">-- 构建一个简单视图
create view vw_score as 
(select id,math_score from score);

select * from vw_score;
update vw_score set math_score = 99 where id = 2;
</code></pre>
<p>多表视图</p>
<pre><code class="language-sql">-- 复杂视图(两张表关联)
create view vw_student_score as 
(select stu.id as id ,stu.name as name ,score.math_score from student stu,score score where stu.id = score.student_id);

select * from vw_student_score;

update vw_student_score set math_score =999 where id = 2;
</code></pre>
<h3 id="95-索引">9.5 索引</h3>
<p><strong>9.5.1 索引的基本概念</strong><br>
先了解概念和使用</p>
<p>索引是数据库中快速查询数据的方法。</p>
<p>索引能提升查询效率的同时，也会带来一些问题</p>
<ul>
<li>
<p>增加了存储空间</p>
</li>
<li>
<p>写操作时，花费的时间比较多</p>
</li>
</ul>
<p>索引可以提升效率，甚至还可以给字段做一些约束</p>
<p><strong>9.5.2 索引的分类</strong></p>
<ul>
<li>
<p>B-Tree索引：最常用的索引。</p>
</li>
<li>
<p>Hash索引：跟MySQL类似，做等值判断，范围凉凉~</p>
</li>
<li>
<p>GIN索引：针对字段的多个值的类型，比如数组类型。</p>
</li>
</ul>
<p><strong>9.5.3 创建索引看效果</strong></p>
<p>准备大量测试数据，方便查看索引效果</p>
<pre><code class="language-sql">-- 测试索引效果
create table tb_index(
    id bigserial primary key,
    name varchar(64),
    phone varchar(64)[]
);

-- 添加300W条数据测试效果
do $$
declare
    i int := 0;
begin
    while i &lt; 3000000 loop
        i = i + 1;
        insert into
            tb_index
        (name,phone) 
            values
        (md5(random()::text || current_timestamp::text)::uuid,array[random()::varchar(64),random()::varchar(64)]);
    end loop;
end;
$$ language plpgsql;
</code></pre>
<p>在没有索引的情况下，先基于name做等值查询，看时间，同时看执行计划</p>
<pre><code class="language-sql">-- c0064192-1836-b019-c649-b368c2be31ca
select * from tb_index where id = 2222222;
select * from tb_index where name = 'c0064192-1836-b019-c649-b368c2be31ca';
explain select * from tb_index where name = 'c0064192-1836-b019-c649-b368c2be31ca';
-- Seq Scan  这个代表全表扫描
-- 时间大致0.3秒左右
</code></pre>
<p>在有索引的情况下，再基于name做等值查询，看时间，同时看执行计划</p>
<pre><code class="language-sql">-- name字段构建索引（默认就是b-tree）
create index index_tb_index_name on tb_index(name);
-- 测试效果
select * from tb_index where name = 'c0064192-1836-b019-c649-b368c2be31ca';
explain select * from tb_index where name = 'c0064192-1836-b019-c649-b368c2be31ca';
-- Index Scan 使用索引
-- 0.1s左右
</code></pre>
<p>测试GIN索引效果</p>
<p>在没有索引的情况下，基于phone字段做包含查询</p>
<pre><code class="language-sql">-- phone：{0.6925242730781953,0.8569644964711074}
select * from tb_index where phone @&gt; array['0.6925242730781953'::varchar(64)];
explain select * from tb_index where phone @&gt; array['0.6925242730781953'::varchar(64)];
-- Seq Scan 全表扫描
-- 0.5s左右
</code></pre>
<p>给phone字段构建GIN索引，在查询</p>
<pre><code class="language-sql">-- 给phone字符串数组类型字段构建一个GIN索引
create index index_tb_index_phone_gin on tb_index using gin(phone);
-- 查询
select * from tb_index where phone @&gt; array['0.6925242730781953'::varchar(64)];
explain select * from tb_index where phone @&gt; array['0.6925242730781953'::varchar(64)];
-- Bitmap Index 位图扫描
-- 0.1s以内完成
</code></pre>
<h3 id="96-物化视图">9.6 物化视图</h3>
<p>前面说过普通视图，本质就是一个SQL语句，普通的视图并不会本地磁盘存储任何物理。</p>
<p>每次查询视图都是执行这个SQL。效率有点问题。</p>
<p>物化视图从名字上就可以看出来，必然是要持久化一份数据的。使用套路和视图基本一致。这样一来查询物化视图，就相当于查询一张单独的表。相比之前的普通视图，物化视图就不需要每次都查询复杂SQL，每次查询的都是真实的物理存储地址中的一份数据（表）。</p>
<p>物化视图因为会持久化到本地，完全脱离原来的表结构。</p>
<p>而且物化视图是可以单独设置索引等信息来提升物化视图的查询效率。</p>
<p>But，有好处就有坏处，更新时间不太好把控。 如果更新频繁，对数据库压力也不小。 如果更新不频繁，会造成数据存在延迟问题，实时性就不好了。</p>
<p>如果要更新物化视图，可以采用触发器的形式，当原表中的数据被写后，可以通过触发器执行同步物化视图的操作。或者就基于定时任务去完成物化视图的数据同步。</p>
<p>look 一下语法。</p>
<figure data-type="image" tabindex="12"><img src="https://tianxiawuhao.github.io/post-images/4105463882b2dfe3724f694b9dcdb0fe.png" alt="" loading="lazy"></figure>
<p>干活！</p>
<pre><code class="language-sql">-- 构建物化视图
create materialized view mv_test as (select id,name,price from test);
-- 操作物化视图和操作表的方式没啥区别。
select * from mv_test;
-- 操作原表时，对物化视图没任何影响
insert into test values (4,'月饼',50,10);
-- 物化视图的添加操作(不允许写物化视图)，会报错
insert into mv_test values (5,'大阅兵',66);
</code></pre>
<p>物化视图如何从原表中进行同步操作。</p>
<p>PostgreSQL中，对物化视图的同步，提供了两种方式，一种是全量更新，另一种是增量更新。</p>
<p>全量更新语法，没什么限制，直接执行，全量更新</p>
<pre><code class="language-sql">-- 查询原来物化视图的数据
select * from mv_test;
-- 全量更新物化视图
refresh materialized view mv_test;
-- 再次查询物化视图的数据
select * from mv_test;
</code></pre>
<p>增量更新，增量更新需要一个唯一标识，来判断哪些是增量，同时也会有行数据的版本号约束。</p>
<pre><code class="language-sql">-- 查询原来物化视图的数据
select * from mv_test;
-- 增量更新物化视图，因为物化视图没有唯一索引，无法判断出哪些是增量数据
refresh materialized view concurrently mv_test;
-- 给物化视图添加唯一索引。
create unique index index_mv_test on mv_test(id);
-- 增量更新物化视图
refresh materialized view concurrently mv_test;
-- 再次查询物化视图的数据
select * from mv_test;
-- 增量更新时，即便是修改数据，物化视图的同步，也会根据一个xmin和xmax的字段做正常的数据同步

update test set name = '汤圆' where id = 5;
insert into test values (5,'猪头肉',99,40);
select * from test;
</code></pre>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%83-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">七、数据类型</a></li>
<li><a href="#%E5%85%AB-postgresql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">八、PostgreSQL基本操作&amp;数据类型</a>
<ul>
<li><a href="#81-%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7">8.1 单引号和双引号</a></li>
<li><a href="#82-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">8.2 数据类型转换</a></li>
<li><a href="#84-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">8.4 数值类型</a>
<ul>
<li><a href="#841-%E6%95%B4%E5%9E%8B">8.4.1 整型</a></li>
<li><a href="#842-%E6%B5%AE%E7%82%B9%E5%9E%8B">8.4.2 浮点型</a></li>
<li><a href="#843-%E5%BA%8F%E5%88%97">8.4.3 序列</a></li>
<li><a href="#844-%E6%95%B0%E5%80%BC%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">8.4.4 数值的常见操作</a></li>
</ul>
</li>
<li><a href="#85-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">8.5 字符串类型</a></li>
<li><a href="#86-%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B">8.6 日期类型</a></li>
<li><a href="#87-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">8.7 枚举类型</a></li>
<li><a href="#88-ip%E7%B1%BB%E5%9E%8B">8.8 IP类型</a></li>
<li><a href="#89-jsonjsonb%E7%B1%BB%E5%9E%8B">8.9 JSON&amp;JSONB类型</a></li>
<li><a href="#810-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">8.10 复合类型</a></li>
<li><a href="#811-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B">8.11 数组类型</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E8%A1%A8">九、表</a>
<ul>
<li><a href="#91-%E7%BA%A6%E6%9D%9F">9.1 约束</a></li>
<li><a href="#92-%E8%A7%A6%E5%8F%91%E5%99%A8">9.2 触发器</a></li>
<li><a href="#93-%E8%A1%A8%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98%E5%A1%AB%E5%9D%91">9.3 表空间（问题填坑）</a></li>
<li><a href="#95-%E7%B4%A2%E5%BC%95">9.5 索引</a></li>
<li><a href="#96-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE">9.6 物化视图</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/uSSvVMkpS/">
                <span class="post-title">
                  PostgreSQL概述三&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/IKbaKSlgE1/">
              <span class="post-title">
                PostgreSQL概述一&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>