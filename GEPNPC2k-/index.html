<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>Java实现License授权许可和验证 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="Java实现License授权许可和验证 | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="Java实现License授权许可和验证" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/GEPNPC2k-/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/psnSEjLwH/" class="tag">license</a>
                
                <a href="https://tianxiawuhao.github.io/6l4aXFMiY/" class="tag">java</a>
                
              </span>
              <h1>Java实现License授权许可和验证</h1>
              <span class="meta">
                Posted on
                2022-11-01，15 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/GEPNPC2k-.png" alt="封面图">
          </img>
          
          <h3 id="truelicense">TrueLicense</h3>
<p>TrueLicense是一个开源的证书管理引擎，使用场景：当项目交付给客户之后用签名来保证客户不能随意使用项目 默认校验了开始结束时间，可扩展增加mac地址校验等。 其中还有ftp的校验没有尝试，本demo详细介绍的是本地校验 license授权机制的原理： 生成密钥对，方法有很多。我们使用trueLicense来做软件产品的保护，我们主要使用它的LicenseManager类来生成证书文件、安装证书文件、验证证书文件.</p>
<h3 id="原理">原理</h3>
<ul>
<li>首先需要生成密钥对，方法有很多，JDK中提供的KeyTool即可生成。</li>
<li>授权者保留私钥，使用私钥对包含授权信息（如截止日期，MAC地址等）的license进行数字签名。</li>
<li>公钥交给使用者（放在验证的代码中使用），用于验证license是否符合使用条件。</li>
</ul>
<h3 id="使用keytool命令生成密钥对">使用Keytool命令生成密钥对</h3>
<blockquote>
<p>Keytool 是一个Java 数据证书的管理工具 ,Keytool 将密钥（key）和证书（certificates）存在一个称为keystore的文件中 在keystore里，包含两种数据：<br>
密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密）<br>
可信任的证书实体（trusted certificate entries）——只包含公钥</p>
</blockquote>
<p>在接触代码前，我们先来大概熟悉下密钥生成的流程吧</p>
<ul>
<li>
<p>首先要用<code>KeyTool</code>工具来生成私匙库：（-alias别名 –validity 3650表示10年有效）</p>
<pre><code class="language-shell"> keytool -genkey -alias privatekey -keystore privateKeys.store -keysize 1024 -validity 3650 -storepass &quot;XXXX&quot; -keypass &quot;XXXX&quot; -dname &quot;CN=test, OU=test, O=Space, L=SH, ST=SH, C=CN&quot;
</code></pre>
<blockquote>
<p>这里密码我使用XXXX<br>
注意！！！默认的密码策略是6位数字与字母，如果不遵守会报错</p>
<p>这个时候，会在打开命令行的地方创建出一个文件，privateKeys.store</p>
</blockquote>
</li>
<li>
<p>然后把私匙库内的证书导出到一个文件当中：</p>
<pre><code class="language-shell">keytool -export -alias privatekey -file certfile.cer -keystore privateKeys.store
</code></pre>
<blockquote>
<p>生成certfile.cer(证书)，生成公钥库后就没什么用了</p>
</blockquote>
</li>
<li>
<p>然后再把这个证书文件导入到公匙库：</p>
<pre><code class="language-shell">keytool -import -alias publiccert -file certfile.cer -keystore publicCerts.store
</code></pre>
<blockquote>
<p>生成 publicCerts.store</p>
</blockquote>
</li>
</ul>
<pre><code class="language-text">privateKeys.keystore：私钥，这个我们自己留着，不能泄露给别人。
publicCerts.keystore：公钥，这个给客户用的。在我们程序里面就是用他配合license进行授权信息的校验的。
certfile.cer：这个文件没啥用，可以删掉。
</code></pre>
<p>最后自行将生成文件<code>privateKeys.store</code>、<code>publicCerts.store</code>拷贝出来备用。</p>
<h3 id="实现代码-证书生成">实现代码 - 证书生成</h3>
<p><strong>maven依赖</strong></p>
<pre><code class="language-xml">&lt;!--truelicense 依赖--&gt;
&lt;!-- https://mvnrepository.com/artifact/de.schlichtherle.truelicense/truelicense-core --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;de.schlichtherle.truelicense&lt;/groupId&gt;
    &lt;artifactId&gt;truelicense-core&lt;/artifactId&gt;
    &lt;version&gt;1.33&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>首先从整个流程上来讲，现在这步是证书生成，证书生成需要私钥库和证书参数<br>
在这个引擎中，公/私钥库默认是存储在项目中的。<strong>但是，我们实际生产环境中，都是将配置文件等脱离项目部署的</strong>，所以我们需要重写它获取公/私钥库的地方。<br>
<code>CustomKeyStoreParam.java</code></p>
<pre><code class="language-java">import de.schlichtherle.license.AbstractKeyStoreParam;
import org.springframework.util.ResourceUtils;

import java.io.*;

/**
 * 自定义KeyStoreParam，用于将公私钥存储文件存放到其他磁盘位置而不是项目中。现场使用的时候公钥大部分都不会放在项目中的
 */
public class CustomKeyStoreParam extends AbstractKeyStoreParam {

    /**
     * 公钥/私钥在磁盘上的存储路径
     */
    private final String storePath;
    private final String alias;
    private final String storePwd;
    private final String keyPwd;

    public CustomKeyStoreParam(Class clazz, String resource, String alias, String storePwd, String keyPwd) {
        super(clazz, resource);
        this.storePath = resource;
        this.alias = alias;
        this.storePwd = storePwd;
        this.keyPwd = keyPwd;
    }


    @Override
    public String getAlias() {
        return alias;
    }

    @Override
    public String getStorePwd() {
        return storePwd;
    }

    @Override
    public String getKeyPwd() {
        return keyPwd;
    }

    /**
     * AbstractKeyStoreParam里面的getStream()方法默认文件是存储的项目中。
     * 用于将公私钥存储文件存放到其他磁盘位置而不是项目中
     */
    @Override
    public InputStream getStream() throws IOException {
//        return new FileInputStream(new File(storePath));
        File file = ResourceUtils.getFile(storePath);
        if (file.exists()) {
            return new FileInputStream(file);
        } else {
            throw new FileNotFoundException(storePath);
        }
    }
}
</code></pre>
<p>证书参数可以用配置文件配置，也可以写成类，这个方法用的就是类的方式</p>
<p><code>License.java</code></p>
<pre><code class="language-java">import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * License生成类需要的参数
 */
@Data
public class License implements Serializable {

    private static final long serialVersionUID = -7793154252684580872L;
    /**
     * 证书subject
     */
    private String subject;

    /**
     * 私钥别称
     */
    private String privateAlias;

    /**
     * 私钥密码（需要妥善保管，不能让使用者知道）
     */
    private String keyPass;

    /**
     * 访问私钥库的密码
     */
    private String storePass;

    /**
     * 证书生成路径
     */
    private String licensePath;

    /**
     * 私钥库存储路径
     */
    private String privateKeysStorePath;

    /**
     * 证书生效时间
     */
    private Date issuedTime = new Date();

    /**
     * 证书失效时间
     */
    private Date expiryTime;

    /**
     * 用户类型
     */
    private String consumerType = &quot;user&quot;;

    /**
     * 用户数量
     */
    private Integer consumerAmount = 1;

    /**
     * 描述信息
     */
    private String description = &quot;&quot;;

    /**
     * 额外的服务器硬件校验信息
     */
    private LicenseExtraModel licenseExtraModel;
}

</code></pre>
<p>其中的扩展参数类</p>
<pre><code class="language-java">/**
 * 自定义需要校验的License参数，可以增加一些额外需要校验的参数，比如项目信息，ip地址信息等等，待完善
 */
public class LicenseExtraModel {

    // 这里可以添加一些往外的自定义信息，比如我们可以增加项目验证，客户电脑sn码的验证等等

}
</code></pre>
<p>由于引擎本身默认只验证了有效期，当我们需要自定义一个继承于LicenseManager的自定义证书管理器。<br>
额外的信息的校验可以加在validate()方法里</p>
<p><code>CustomLicenseManager.java</code></p>
<pre><code class="language-java">import de.schlichtherle.license.*;
import de.schlichtherle.xml.GenericCertificate;
import de.schlichtherle.xml.XMLConstants;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.beans.XMLDecoder;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;

/**
 * 自定义LicenseManager，用于增加额外的信息校验(除了LicenseManager的校验，我们还可以在这个类里面添加额外的校验信息)
 */
public class CustomLicenseManager extends LicenseManager {

    private static Logger logger = LogManager.getLogger(CustomLicenseManager.class);

    public CustomLicenseManager(LicenseParam param) {
        super(param);
    }

    /**
     * 复写create方法
     */
    @Override
    protected synchronized byte[] create(LicenseContent content, LicenseNotary notary) throws Exception {
        initialize(content);
        this.validateCreate(content);
        final GenericCertificate certificate = notary.sign(content);
        return getPrivacyGuard().cert2key(certificate);
    }

    /**
     * 复写install方法，其中validate方法调用本类中的validate方法，校验IP地址、Mac地址等其他信息
     */
    @Override
    protected synchronized LicenseContent install(final byte[] key, final LicenseNotary notary) throws Exception {
        final GenericCertificate certificate = getPrivacyGuard().key2cert(key);
        notary.verify(certificate);
        final LicenseContent content = (LicenseContent) this.load(certificate.getEncoded());
        this.validate(content);
        setLicenseKey(key);
        setCertificate(certificate);

        return content;
    }

    /**
     * 复写verify方法，调用本类中的validate方法，校验IP地址、Mac地址等其他信息
     */
    @Override
    protected synchronized LicenseContent verify(final LicenseNotary notary) throws Exception {

        // Load license key from preferences,
        final byte[] key = getLicenseKey();
        if (null == key) {
            throw new NoLicenseInstalledException(getLicenseParam().getSubject());
        }

        GenericCertificate certificate = getPrivacyGuard().key2cert(key);
        notary.verify(certificate);
        final LicenseContent content = (LicenseContent) this.load(certificate.getEncoded());
        this.validate(content);
        setCertificate(certificate);

        return content;
    }

    /**
     * 校验生成证书的参数信息
     */
    protected synchronized void validateCreate(final LicenseContent content) throws LicenseContentException {
        final LicenseParam param = getLicenseParam();
        final Date now = new Date();
        final Date notBefore = content.getNotBefore();
        final Date notAfter = content.getNotAfter();
        if (null != notAfter &amp;&amp; now.after(notAfter)) {
            throw new LicenseContentException(&quot;证书失效时间不能早于当前时间&quot;);
        }
        if (null != notBefore &amp;&amp; null != notAfter &amp;&amp; notAfter.before(notBefore)) {
            throw new LicenseContentException(&quot;证书生效时间不能晚于证书失效时间&quot;);
        }
        final String consumerType = content.getConsumerType();
        if (null == consumerType) {
            throw new LicenseContentException(&quot;用户类型不能为空&quot;);
        }
    }


    /**
     * 复写validate方法，用于增加我们额外的校验信息
     */
    @Override
    protected synchronized void validate(final LicenseContent content) throws LicenseContentException {
        //1. 首先调用父类的validate方法
        super.validate(content);
        //2. 然后校验自定义的License参数，去校验我们的license信息
//        LicenseExtraModel expectedCheckModel = (LicenseExtraModel) content.getExtra();
        // 做我们自定义的校验
    }


    /**
     * 重写XMLDecoder解析XML
     */
    private Object load(String encoded) {
        BufferedInputStream inputStream = null;
        XMLDecoder decoder = null;
        try {
            inputStream = new BufferedInputStream(new ByteArrayInputStream(encoded.getBytes(XMLConstants.XML_CHARSET)));
            decoder = new XMLDecoder(new BufferedInputStream(inputStream, XMLConstants.DEFAULT_BUFSIZE), null, null);
            return decoder.readObject();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } finally {
            try {
                if (decoder != null) {
                    decoder.close();
                }
                if (inputStream != null) {
                    inputStream.close();
                }
            } catch (Exception e) {
                logger.error(&quot;XMLDecoder解析XML失败&quot;, e);
            }
        }

        return null;
    }

}
</code></pre>
<p>前面的所有可以说都是为了整个流程在铺垫，现在开始是真正开始生成License证书的代码</p>
<p><code>LicenseCreator.java</code></p>
<pre><code class="language-java">import de.schlichtherle.license.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.security.auth.x500.X500Principal;
import java.io.File;
import java.text.MessageFormat;
import java.util.prefs.Preferences;

/**
 * License生成类 -- 用于license生成
 */
public class LicenseCreator {

    private final static X500Principal DEFAULT_HOLDER_AND_ISSUER = new X500Principal(&quot;CN=Haier, OU=Haier, O=Space, L=SH, ST=SH, C=CN&quot;);

    private static final Logger logger = LogManager.getLogger(LicenseCreator.class);

    private final License license;

    public LicenseCreator(License license) {
        this.license = license;
    }

    /**
     * 生成License证书
     */
    public boolean generateLicense() {
        try {
            LicenseManager licenseManager = new CustomLicenseManager(initLicenseParam());
            LicenseContent licenseContent = initLicenseContent();
            licenseManager.store(licenseContent, new File(license.getLicensePath()));
            return true;
        } catch (Exception e) {
            logger.error(MessageFormat.format(&quot;证书生成失败：{0}&quot;, license), e);
            return false;
        }
    }

    /**
     * 初始化证书生成参数
     */
    private LicenseParam initLicenseParam() {
        Preferences preferences = Preferences.userNodeForPackage(LicenseCreator.class);

        //设置对证书内容加密的秘钥
        CipherParam cipherParam = new DefaultCipherParam(license.getStorePass());

        KeyStoreParam privateStoreParam = new CustomKeyStoreParam(LicenseCreator.class, 
                license.getPrivateKeysStorePath(),
                license.getPrivateAlias(),
                license.getStorePass(),
                license.getKeyPass());

        return new DefaultLicenseParam(license.getSubject(),
                preferences,
                privateStoreParam,
                cipherParam);
    }

    /**
     * 设置证书生成正文信息
     */
    private LicenseContent initLicenseContent() {
        LicenseContent licenseContent = new LicenseContent();
        licenseContent.setHolder(DEFAULT_HOLDER_AND_ISSUER);
        licenseContent.setIssuer(DEFAULT_HOLDER_AND_ISSUER);

        licenseContent.setSubject(license.getSubject());
        licenseContent.setIssued(license.getIssuedTime());
        licenseContent.setNotBefore(license.getIssuedTime());
        licenseContent.setNotAfter(license.getExpiryTime());
        licenseContent.setConsumerType(license.getConsumerType());
        licenseContent.setConsumerAmount(license.getConsumerAmount());
        licenseContent.setInfo(license.getDescription());

        //扩展校验，这里可以自定义一些额外的校验信息(也可以用json字符串保存)
        if (license.getLicenseExtraModel() != null) {
            licenseContent.setExtra(license.getLicenseExtraModel());
        }

        return licenseContent;
    }

}
</code></pre>
<h3 id="测试-证书生成">测试 - 证书生成</h3>
<p>环境工具类都准备好了，接下来直接开始测试，看看能否生成</p>
<pre><code class="language-java">@Test
void generateLicense() {
    // 生成license需要的一些参数
    License param = new License();
    // 证书授权主体
    param.setSubject(&quot;licenseTest&quot;);
    // 私钥别名
    param.setPrivateAlias(&quot;privateKey&quot;);
    // 私钥密码（需要妥善保管，不能让使用者知道）
    param.setKeyPass(&quot;xxxx&quot;);
    // 访问私钥库的密码
    param.setStorePass(&quot;xxxx&quot;);
    // 证书存储地址
    param.setLicensePath(&quot;E:\\license2\\license.lic&quot;);
    // 私钥库所在地址
    param.setPrivateKeysStorePath(&quot;E:\\license\\privateKeys.store&quot;);
    // 证书生效时间
    Calendar issueCalendar = Calendar.getInstance();
    param.setIssuedTime(issueCalendar.getTime());
    // 证书失效时间
    Calendar expiryCalendar = Calendar.getInstance();
    // 设置当前时间
    expiryCalendar.setTime(new Date());
    // 往后延长一年 = 授权一年时间
    expiryCalendar.add(Calendar.YEAR,1);
    param.setExpiryTime(expiryCalendar.getTime());
    // 用户类型
    param.setConsumerType(&quot;user&quot;);
    // 用户数量
    param.setConsumerAmount(1);
    // 描述
    param.setDescription(&quot;测试&quot;);
    LicenseCreator licenseCreator = new LicenseCreator(param);
    // 生成license
    licenseCreator.generateLicense();
}
</code></pre>
<h3 id="代码实现-证书安装和校验">代码实现 - 证书安装和校验</h3>
<p>就像证书生成，验证也需要一个专门的类</p>
<p><code>LicenseVerify.java</code></p>
<pre><code class="language-java">import de.schlichtherle.license.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.prefs.Preferences;

/**
 * License校验类
 */
public class LicenseVerify {

    private static Logger logger = LogManager.getLogger(LicenseVerify.class);
    /**
     * 证书subject
     */
    private final String subject;
    /**
     * 公钥别称
     */
    private final String publicAlias;
    /**
     * 访问公钥库的密码
     */
    private final String storePass;
    /**
     * 证书生成路径
     */
    private final String licensePath;
    /**
     * 密钥库存储路径
     */
    private final String publicKeysStorePath;
    /**
     * LicenseManager
     */
    private LicenseManager  licenseManager;
    /**
     * 标识证书是否安装成功
     */
    private boolean installSuccess;

    public LicenseVerify(String subject, String publicAlias, String storePass, String licensePath, String publicKeysStorePath) {
        this.subject = subject;
        this.publicAlias = publicAlias;
        this.storePass = storePass;
        this.licensePath = licensePath;
        this.publicKeysStorePath = publicKeysStorePath;
    }

    /**
     * 安装License证书，读取证书相关的信息, 在bean加入容器的时候自动调用
     */
    public void installLicense() {
        try {
            Preferences preferences = Preferences.userNodeForPackage(LicenseVerify.class);

            CipherParam cipherParam = new DefaultCipherParam(storePass);

            KeyStoreParam publicStoreParam = new CustomKeyStoreParam(LicenseVerify.class,
                    publicKeysStorePath,
                    publicAlias,
                    storePass,
                    null);
            LicenseParam licenseParam = new DefaultLicenseParam(subject, preferences, publicStoreParam, cipherParam);

            licenseManager = new CustomLicenseManager(licenseParam);
            licenseManager.uninstall();
            LicenseContent licenseContent = licenseManager.install(new File(licensePath));
            DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            installSuccess = true;
            logger.info(&quot;------------------------------- 证书安装成功 -------------------------------&quot;);
            logger.info(MessageFormat.format(&quot;证书有效期：{0} - {1}&quot;, format.format(licenseContent.getNotBefore()), format.format(licenseContent.getNotAfter())));
        } catch (Exception e) {
            installSuccess = false;
            logger.error(&quot;------------------------------- 证书安装失败 -------------------------------&quot;);
            logger.error(e);
        }
    }

    /**
     * 卸载证书，在bean从容器移除的时候自动调用
     */
    public void unInstallLicense() {
        if (installSuccess) {
            try {
                licenseManager.uninstall();
            } catch (Exception e) {
                // ignore
            }
        }
    }

    /**
     * 校验License证书
     */
    public boolean verify() {
        try {
            licenseManager.verify();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

}
</code></pre>
<p>我们之前说了，除了项目许多的配置文件我们一般是需要放在服务器单独的路径下的，除了公钥和私钥库，还有我们验证需要配置的一些参数</p>
<p><code>application.yml</code></p>
<pre><code class="language-xml">#License相关配置
license:
 subject: licenseTest #主体 - 注意主体要与生成证书的主体一致一致，不然验证通过不了
 publicAlias: publicCert #公钥别称
 storePass: 123456q #访问公钥的密码
 licensePath: E:\license2\license.lic #license位置
 publicKeysStorePath: E:\license\publicCerts.store #公钥位置
</code></pre>
<p>这些参数代码获取如下</p>
<p><code>LicenseConfig.java</code></p>
<pre><code class="language-java">import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = &quot;license&quot;)
public class LicenseConfig {

    /**
     * 证书subject
     */
    private String subject;

    /**
     * 公钥别称
     */
    private String publicAlias;

    /**
     * 访问公钥库的密码
     */
    private String storePass;

    /**
     * 证书生成路径
     */
    private String licensePath;

    /**
     * 密钥库存储路径
     */
    private String publicKeysStorePath;

    @Bean(initMethod = &quot;installLicense&quot;, destroyMethod = &quot;unInstallLicense&quot;)
    public LicenseVerify licenseVerify() {
        return new LicenseVerify(subject, publicAlias, storePass, licensePath, publicKeysStorePath);
    }

}
</code></pre>
<p>以上代码是读取<code>yml</code>的配置，以及将<code>LicenseConfig</code>加入<code>Spring</code>容器，在加入<code>Spring</code>容器的同时，执行<code>licenseVerify</code>里的安装方法</p>
<p>这样，程序就会在启动时，自动安装证书，校验时就可以用了</p>
<pre><code class="language-java">@SpringBootTest
@RunWith(SpringRunner.class)
public class LicenseVerifyTest {

    private LicenseVerify licenseVerify;
    
    @Autowired
    public void setLicenseVerify(LicenseVerify licenseVerify) {
        this.licenseVerify = licenseVerify;
    }
    
    @Test
    public void licenseVerify() {
       System.out.println(&quot;licese是否有效：&quot; + licenseVerify.verify());
    }

}
</code></pre>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#truelicense">TrueLicense</a></li>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8keytool%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9">使用Keytool命令生成密钥对</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90">实现代码 - 证书生成</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95-%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90">测试 - 证书生成</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85%E5%92%8C%E6%A0%A1%E9%AA%8C">代码实现 - 证书安装和校验</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/OxvAGnY87/">
                <span class="post-title">
                  easeCode&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/DCnCuY10S/">
              <span class="post-title">
                切面链实现&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>