<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>机器学习算法(仅了解) | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="机器学习算法(仅了解) | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="机器学习算法(仅了解)" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/J6vCn9W4Z/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/PjnFH7MKT/" class="tag">机器学习</a>
                
                <a href="https://tianxiawuhao.github.io/nUOlUI5VKeM/" class="tag">算法</a>
                
              </span>
              <h1>机器学习算法(仅了解)</h1>
              <span class="meta">
                Posted on
                2024-05-08，18 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/J6vCn9W4Z.png" alt="封面图">
          </img>
          
          <h2 id="机器学习分类">机器学习分类</h2>
<p>根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。</p>
<figure data-type="image" tabindex="1"><img src="https://tianxiawuhao.github.io/post-images/640.webp" alt="" loading="lazy"></figure>
<h3 id="监督学习">监督学习：</h3>
<figure data-type="image" tabindex="2"><img src="https://tianxiawuhao.github.io/post-images/641.webp" alt="" loading="lazy"></figure>
<p>在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。<strong>监督式学习的常见应用场景如分类问题和回归问题</strong>。常见算法有逻辑回归（Logistic Regression）和反向传递神经网络（Back Propagation Neural Network）</p>
<h3 id="非监督学习">非监督学习：</h3>
<figure data-type="image" tabindex="3"><img src="https://tianxiawuhao.github.io/post-images/642.webp" alt="" loading="lazy"></figure>
<p>在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。<strong>常见的应用场景包括关联规则的学习以及聚类等</strong>。常见算法包括Apriori算法以及k-Means算法。</p>
<h3 id="半监督学习">半监督学习：</h3>
<figure data-type="image" tabindex="4"><img src="https://tianxiawuhao.github.io/post-images/643.webp" alt="" loading="lazy"></figure>
<p>在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如<strong>图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。</strong></p>
<h3 id="强化学习">强化学习：</h3>
<figure data-type="image" tabindex="5"><img src="https://tianxiawuhao.github.io/post-images/644.webp" alt="" loading="lazy"></figure>
<p>在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。<strong>常见算法包括Q-Learning以及时间差学习（Temporal difference learning）</strong></p>
<p>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。</p>
<h2 id="算法分类">算法分类</h2>
<p>根据算法的功能和形式的类似性，我们可以把算法分类，比如说基于树的算法，基于神经网络的算法等等。当然，机器学习的范围非常庞大，有些算法很难明确归类到某一类。而对于有些分类来说，<strong>同一分类的算法可以针对不同类型的问题</strong>。这里，我们尽量把常用的算法按照最容易理解的方式进行分类。</p>
<h3 id="回归算法">回归算法：</h3>
<figure data-type="image" tabindex="6"><img src="https://tianxiawuhao.github.io/post-images/645.webp" alt="" loading="lazy"></figure>
<p>回归算法是试图采用对误差的衡量来探索变量之间的关系的一类算法。回归算法是统计机器学习的利器。在机器学习领域，人们说起回归，有时候是指一类问题，有时候是指一类算法，这一点常常会使初学者有所困惑。常见的回归算法包括：最小二乘法（Ordinary Least Square），逻辑回归（Logistic Regression），逐步式回归（Stepwise Regression），多元自适应回归样条（Multivariate Adaptive Regression Splines）以及本地散点平滑估计（Locally Estimated Scatterplot Smoothing）</p>
<h3 id="基于实例的算法">基于实例的算法</h3>
<figure data-type="image" tabindex="7"><img src="https://tianxiawuhao.github.io/post-images/646.webp" alt="" loading="lazy"></figure>
<p>基于实例的算法常常用来对决策问题建立模型，这样的模型常常先选取一批样本数据，然后根据某些近似性把新数据与样本数据进行比较。通过这种方式来寻找最佳的匹配。因此，基于实例的算法常常也被称为“赢家通吃”学习或者“基于记忆的学习”。常见的算法包括 k-Nearest Neighbor(KNN), 学习矢量量化（Learning Vector Quantization， LVQ），以及自组织映射算法（Self-Organizing Map ， SOM）</p>
<h3 id="正则化方法">正则化方法</h3>
<figure data-type="image" tabindex="8"><img src="https://tianxiawuhao.github.io/post-images/647.webp" alt="" loading="lazy"></figure>
<p>正则化方法是其他算法（通常是回归算法）的延伸，根据算法的复杂度对算法进行调整。<strong>正则化方法通常对简单模型予以奖励而对复杂算法予以惩罚</strong>。常见的算法包括：Ridge Regression，Least Absolute Shrinkage and Selection Operator（LASSO），以及弹性网络（Elastic Net）。</p>
<h3 id="决策树学习">决策树学习</h3>
<figure data-type="image" tabindex="9"><img src="https://tianxiawuhao.github.io/post-images/648.webp" alt="" loading="lazy"></figure>
<p>决策树算法根据数据的属性采用树状结构建立决策模型， 决策树模型常常用来解决分类和回归问题。常见的算法包括：分类及回归树（Classification And Regression Tree， CART）， ID3 (Iterative Dichotomiser 3)， C4.5， Chi-squared Automatic Interaction Detection(CHAID), Decision Stump, 随机森林（Random Forest）， 多元自适应回归样条（MARS）以及梯度推进机（Gradient Boosting Machine， GBM）</p>
<h3 id="贝叶斯方法">贝叶斯方法</h3>
<figure data-type="image" tabindex="10"><img src="https://tianxiawuhao.github.io/post-images/649.webp" alt="" loading="lazy"></figure>
<p>贝叶斯方法算法是基于贝叶斯定理的一类算法，主要用来解决分类和回归问题。常见算法包括：朴素贝叶斯算法，平均单依赖估计（Averaged One-Dependence Estimators， AODE），以及Bayesian Belief Network（BBN）。</p>
<h3 id="基于核的算法">基于核的算法</h3>
<figure data-type="image" tabindex="11"><img src="https://tianxiawuhao.github.io/post-images/650.webp" alt="" loading="lazy"></figure>
<p>基于核的算法中最著名的莫过于支持向量机（SVM）了。基于核的算法把输入数据映射到一个高阶的向量空间， 在这些高阶向量空间里， 有些分类或者回归问题能够更容易的解决。常见的基于核的算法包括：支持向量机（Support Vector Machine， SVM）， 径向基函数（Radial Basis Function ，RBF)， 以及线性判别分析（Linear Discriminate Analysis ，LDA)等</p>
<h3 id="聚类算法">聚类算法</h3>
<figure data-type="image" tabindex="12"><img src="https://tianxiawuhao.github.io/post-images/651.webp" alt="" loading="lazy"></figure>
<p>聚类，就像回归一样，有时候人们描述的是一类问题，有时候描述的是一类算法。聚类算法通常按照中心点或者分层的方式对输入数据进行归并。<strong>所以的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类</strong>。常见的聚类算法包括 k-Means算法以及期望最大化算法（Expectation Maximization， EM）。</p>
<h3 id="人工神经网络">人工神经网络</h3>
<figure data-type="image" tabindex="13"><img src="https://tianxiawuhao.github.io/post-images/654.webp" alt="" loading="lazy"></figure>
<p>人工神经网络算法模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络是机器学习的一个庞大的分支，有几百种不同的算法。（其中深度学习就是其中的一类算法，我们会单独讨论），重要的人工神经网络算法包括：感知器神经网络（Perceptron Neural Network）, 反向传递（Back Propagation）， Hopfield网络，自组织映射（Self-Organizing Map, SOM）。学习矢量量化（Learning Vector Quantization， LVQ）</p>
<h3 id="深度学习">深度学习</h3>
<figure data-type="image" tabindex="14"><img src="https://tianxiawuhao.github.io/post-images/655.webp" alt="" loading="lazy"></figure>
<p>深度学习算法是对人工神经网络的发展。在近期赢得了很多关注， 特别是百度也开始发力深度学习后， 更是在国内引起了很多关注。  在计算能力变得日益廉价的今天，深度学习试图建立大得多也复杂得多的神经网络。很多深度学习的算法是半监督式学习算法，用来处理存在少量未标识数据的大数据集。常见的深度学习算法包括：受限波尔兹曼机（Restricted Boltzmann Machine， RBN）， Deep Belief Networks（DBN），卷积网络（Convolutional Network）, 堆栈式自动编码器（Stacked Auto-encoders）。</p>
<h2 id="常见算法优劣">常见算法优劣</h2>
<h3 id="朴素贝叶斯"><strong>朴素贝叶斯：</strong></h3>
<p>如果给出的特征向量长度可能不同，这是需要归一化为通长度的向量（这里以文本分类为例），比如说是句子单词的话，则长度为整个词汇量的长度，对应位置是该单词出现的次数。</p>
<h4 id="函数表达式">函数表达式：</h4>
<figure data-type="image" tabindex="15"><img src="https://tianxiawuhao.github.io/post-images/660.webp" alt="" loading="lazy"></figure>
<p>其中一项条件概率可以通过朴素贝叶斯条件独立展开。要注意一点就是 <img src="https://tianxiawuhao.github.io/post-images/689.webp" alt="" loading="lazy"> ，因此一般有两种，一种是在类别为ci的那些样本集中，找到wj出现次数的总和，然后除以该样本的总和；第二种方法是类别为ci的那些样本集中，找到wj出现次数的总和，然后除以该样本中所有特征出现次数的总和。</p>
<blockquote>
<p>如果 <img src="https://tianxiawuhao.github.io/post-images/660-1.webp" alt="" loading="lazy">中的某一项为0，则其联合概率的乘积也可能为0，即2中公式的分子为0，为了避免这种现象出现，一般情况下会将这一项初始化为1，当然为了保证概率相等，分母应对应初始化为2（这里因为是2类，所以加2，如果是k类就需要加k，术语上叫做laplace光滑, 分母加k的原因是使之满足全概率公式)。</p>
</blockquote>
<h4 id="优点">优点：</h4>
<p>对小规模的数据表现很好，适合多分类任务，适合增量式训练。</p>
<h4 id="缺点">缺点：</h4>
<p>对输入数据的表达形式很敏感。</p>
<h3 id="决策树"><strong>决策树：</strong></h3>
<p>决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。</p>
<h4 id="信息熵的函数表达式">信息熵的函数表达式:</h4>
<figure data-type="image" tabindex="16"><img src="https://tianxiawuhao.github.io/post-images/661.webp" alt="" loading="lazy"></figure>
<p>其中的n代表有n个分类类别（比如假设是2类问题，那么n=2）。分别计算这2类样本在总样本中出现的概率p1和p2，这样就可以计算出未选中属性分枝前的信息熵。</p>
<p>现在选中一个属性xi用来进行分枝，此时分枝规则是：如果xi=vx的话，将样本分到树的一个分支；如果不相等则进入另一个分支。很显然，分支中的样本很有可能包括2个类别，分别计算这2个分支的熵H1和H2,计算出分枝后的总信息熵H’=p1<em>H1+p2</em>H2.，则此时的信息增益ΔH=H-H’。以信息增益为原则，把所有的属性都测试一边，选择一个使增益最大的属性作为本次分枝属性。</p>
<h4 id="优点-2">优点：</h4>
<p>计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征；</p>
<h4 id="缺点-2">缺点：</h4>
<p>容易过拟合（后续出现了随机森林，减小了过拟合现象）。</p>
<h3 id="logistic回归"><strong>Logistic回归：</strong></h3>
<p>Logistic是用来分类的，是一种线性分类器，需要注意的地方有：</p>
<h4 id="函数表达式-2">函数表达式：</h4>
<figure data-type="image" tabindex="17"><img src="https://tianxiawuhao.github.io/post-images/662.webp" alt="" loading="lazy"></figure>
<p>其导数形式为：</p>
<figure data-type="image" tabindex="18"><img src="https://tianxiawuhao.github.io/post-images/663.webp" alt="" loading="lazy"></figure>
<p>logsitc回归方法主要是用最大似然估计来学习的，所以单个样本的后验概率为：</p>
<figure data-type="image" tabindex="19"><img src="https://tianxiawuhao.github.io/post-images/664.webp" alt="" loading="lazy"></figure>
<p>到整个样本的后验概率：</p>
<figure data-type="image" tabindex="20"><img src="https://tianxiawuhao.github.io/post-images/665.webp" alt="" loading="lazy"></figure>
<p>其中：</p>
<figure data-type="image" tabindex="21"><img src="https://tianxiawuhao.github.io/post-images/666.webp" alt="" loading="lazy"></figure>
<p>通过对数进一步化简为：</p>
<figure data-type="image" tabindex="22"><img src="https://tianxiawuhao.github.io/post-images/667.webp" alt="" loading="lazy"></figure>
<p>其实它的loss function为-l(θ)，因此我们需使loss function最小，可采用梯度下降法得到。梯度下降法公式为:</p>
<figure data-type="image" tabindex="23"><img src="https://tianxiawuhao.github.io/post-images/668.webp" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://tianxiawuhao.github.io/post-images/669.webp" alt="" loading="lazy"></figure>
<h4 id="优点-3">优点：</h4>
<ul>
<li>实现简单</li>
<li>分类时计算量非常小，速度很快，存储资源低；</li>
</ul>
<h4 id="缺点-3">缺点：</h4>
<ul>
<li>容易欠拟合，一般准确度不太高</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</li>
</ul>
<h3 id="线性回归"><strong>线性回归：</strong></h3>
<p>线性回归才是真正用于回归的，而不像logistic回归是用于分类，其基本思想是用梯度下降法对最小二乘法形式的误差函数进行优化，当然也可以用normal equation直接求得参数的解</p>
<h4 id="函数表达式-3">函数表达式:</h4>
<figure data-type="image" tabindex="25"><img src="https://tianxiawuhao.github.io/post-images/670.webp" alt="" loading="lazy"></figure>
<p>而在LWLR（局部加权线性回归）中，参数的计算表达式为:</p>
<figure data-type="image" tabindex="26"><img src="https://tianxiawuhao.github.io/post-images/671.webp" alt="" loading="lazy"></figure>
<p>因为此时优化的是：</p>
<figure data-type="image" tabindex="27"><img src="https://tianxiawuhao.github.io/post-images/672.webp" alt="" loading="lazy"></figure>
<p>由此可见LWLR与LR不同，LWLR是一个非参数模型，因为每次进行回归计算都要遍历训练样本至少一次。</p>
<h4 id="优点-4">优点：</h4>
<p>实现简单，计算简单；</p>
<h4 id="缺点-4">缺点：</h4>
<p>不能拟合非线性数据；</p>
<h3 id="最近邻算法knn"><strong>最近邻算法(KNN)：</strong></h3>
<p>KNN算法即最近邻算法，其主要过程为：</p>
<ul>
<li>计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；</li>
<li>对上面所有的距离值进行排序；</li>
<li>选前k个最小距离的样本；</li>
<li>根据这k个样本的标签进行投票，得到最后的分类类别；</li>
</ul>
<p>如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响。但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。<strong>另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小</strong>。</p>
<p>近邻算法具有较强的一致性结果。随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率。</p>
<p>注：马氏距离一定要先给出样本集的统计性质，比如均值向量，协方差矩阵等。关于马氏距离的介绍如下：</p>
<figure data-type="image" tabindex="28"><img src="https://tianxiawuhao.github.io/post-images/673.webp" alt="" loading="lazy"></figure>
<h4 id="优点-5">优点：</h4>
<ul>
<li>思想简单，理论成熟，既可以用来做分类也可以用来做回归；</li>
<li>可用于非线性分类；</li>
<li>训练时间复杂度为O(n)；</li>
<li>准确度高，对数据没有假设，对异常值不敏感；</li>
</ul>
<h4 id="缺点-5">缺点：</h4>
<ul>
<li>计算量大；</li>
<li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</li>
<li>需要大量的内存；</li>
</ul>
<h3 id="支持向量机svm"><strong>支持向量机(SVM)：</strong></h3>
<p>要学会如何使用libsvm以及一些参数的调节经验，另外需要理清楚svm算法的一些思路：</p>
<p>svm中的最优分类面是对所有样本的几何裕量最大（为什么要选择最大间隔分类器，请从数学角度上说明？答案就是几何间隔与样本的误分次数间存在关系：<img src="https://tianxiawuhao.github.io/post-images/674-1.webp" alt="" loading="lazy"> ，其中的分母就是样本到分类间隔距离，分子中的R是所有样本中的最长向量值)</p>
<h4 id="函数表达式-4">函数表达式：</h4>
<figure data-type="image" tabindex="29"><img src="https://tianxiawuhao.github.io/post-images/674.webp" alt="" loading="lazy"></figure>
<p>经过一系列推导可得为优化下面原始目标：</p>
<figure data-type="image" tabindex="30"><img src="https://tianxiawuhao.github.io/post-images/675.webp" alt="" loading="lazy"></figure>
<p>下面来看看拉格朗日理论：</p>
<figure data-type="image" tabindex="31"><img src="https://tianxiawuhao.github.io/post-images/676.webp" alt="" loading="lazy"></figure>
<p>可以将1中的优化目标转换为拉格朗日的形式（通过各种对偶优化，KKD条件），最后目标函数为：</p>
<figure data-type="image" tabindex="32"><img src="https://tianxiawuhao.github.io/post-images/677.webp" alt="" loading="lazy"></figure>
<p>我们只需要最小化上述目标函数，其中的α为原始优化问题中的不等式约束拉格朗日系数。</p>
<p>对2中最后的式子分别w和b求导可得：</p>
<figure data-type="image" tabindex="33"><img src="https://tianxiawuhao.github.io/post-images/678.webp" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="34"><img src="https://tianxiawuhao.github.io/post-images/679.webp" alt="" loading="lazy"></figure>
<p>由上面第1式子可以知道，如果我们优化出了α，则直接可以求出w了，即模型的参数搞定。而上面第2个式子可以作为后续优化的一个约束条件。</p>
<p>对2中最后一个目标函数用对偶优化理论可以转换为优化下面的目标函数：</p>
<figure data-type="image" tabindex="35"><img src="https://tianxiawuhao.github.io/post-images/680.webp" alt="" loading="lazy"></figure>
<p>而这个函数可以用常用的优化方法求得α，进而求得w和b。</p>
<p>按照道理，svm简单理论应该到此结束。不过还是要补充一点，即在预测时有：</p>
<figure data-type="image" tabindex="36"><img src="https://tianxiawuhao.github.io/post-images/681.webp" alt="" loading="lazy"></figure>
<p>那个尖括号我们可以用核函数代替，这也是svm经常和核函数扯在一起的原因。</p>
<p>最后是关于松弛变量的引入，因此原始的目标优化公式为：</p>
<figure data-type="image" tabindex="37"><img src="https://tianxiawuhao.github.io/post-images/682.webp" alt="" loading="lazy"></figure>
<p>此时对应的对偶优化公式为：</p>
<figure data-type="image" tabindex="38"><img src="https://tianxiawuhao.github.io/post-images/683.webp" alt="" loading="lazy"></figure>
<p>与前面的相比只是α多了个上界。</p>
<h4 id="优点-6">优点：</h4>
<ul>
<li>可用于线性/非线性分类，也可以用于回归；</li>
<li>低泛化误差；</li>
<li>容易解释；</li>
<li>计算复杂度较低；</li>
</ul>
<h4 id="缺点-6">缺点：</h4>
<ul>
<li>
<p>对参数和核函数的选择比较敏感；</p>
</li>
<li>
<p>原始的SVM只比较擅长处理二分类问题；</p>
</li>
</ul>
<h3 id="提升方法boosting">提升方法(Boosting)：</h3>
<p>主要以<code>Adaboost</code>为例，首先来看看<code>Adaboost</code>的流程图，如下：</p>
<figure data-type="image" tabindex="39"><img src="https://tianxiawuhao.github.io/post-images/684.webp" alt="" loading="lazy"></figure>
<p>从图中可以看到，在训练过程中我们需要训练出多个弱分类器（图中为3个），每个弱分类器是由不同权重的样本（图中为5个训练样本）训练得到（其中第一个弱分类器对应输入样本的权值是一样的），而每个弱分类器对最终分类结果的作用也不同，是通过加权平均输出的，权值见上图中三角形里面的数值。那么这些弱分类器和其对应的权值是怎样训练出来的呢？</p>
<p>下面通过一个例子来简单说明，假设的是5个训练样本，每个训练样本的维度为2，在训练第一个分类器时5个样本的权重各为0.2. 注意这里样本的权值和最终训练的弱分类器组对应的权值α是不同的，样本的权重只在训练过程中用到，而α在训练过程和测试过程都有用到。</p>
<p>现在假设弱分类器是带一个节点的简单决策树，该决策树会选择2个属性（假设只有2个属性）的一个，然后计算出这个属性中的最佳值用来分类。</p>
<h4 id="adaboost的简单版本训练过程"><strong>Adaboost的简单版本训练过程：</strong></h4>
<ul>
<li>训练第一个分类器，样本的权值D为相同的均值。通过一个弱分类器，得到这5个样本（请对应书中的例子来看，依旧是machine learning in action）的分类预测标签。与给出的样本真实标签对比，就可能出现误差(即错误)。如果某个样本预测错误，则它对应的错误值为该样本的权重，如果分类正确，则错误值为0. 最后累加5个样本的错误率之和，记为ε。</li>
<li>通过ε来计算该弱分类器的权重α，公式如下：</li>
</ul>
<figure data-type="image" tabindex="40"><img src="https://tianxiawuhao.github.io/post-images/685.webp" alt="" loading="lazy"></figure>
<ul>
<li>通过α来计算训练下一个弱分类器样本的权重D，如果对应样本分类正确，则减小该样本的权重，公式为：</li>
</ul>
<figure data-type="image" tabindex="41"><img src="https://tianxiawuhao.github.io/post-images/686.webp" alt="" loading="lazy"></figure>
<p>如果样本分类错误，则增加该样本的权重，公式为：</p>
<figure data-type="image" tabindex="42"><img src="https://tianxiawuhao.github.io/post-images/687.webp" alt="" loading="lazy"></figure>
<ul>
<li>循环步骤1,2,3来继续训练多个分类器，只是其D值不同而已。</li>
</ul>
<h4 id="优点-7">优点：</h4>
<ul>
<li>低泛化误差；</li>
<li>容易实现，分类准确率较高，没有太多参数可以调；</li>
</ul>
<h4 id="缺点-7">缺点：</h4>
<ul>
<li>对异常值比较敏感；</li>
</ul>
<h3 id="聚类">聚类：</h3>
<p><strong>基于划分的聚类:</strong></p>
<p>k-means是使下面的表达式值最小</p>
<h4 id="函数表达式-5">函数表达式:</h4>
<figure data-type="image" tabindex="43"><img src="https://tianxiawuhao.github.io/post-images/688.webp" alt="" loading="lazy"></figure>
<h4 id="优点-8">优点：</h4>
<ul>
<li>k-means算法是解决聚类问题的一种经典算法，算法简单、快速。</li>
<li>对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k&lt;</li>
<li>算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。</li>
</ul>
<h4 id="缺点-8">缺点：</h4>
<ul>
<li>k-平均方法只有在簇的平均值被定义的情况下才能使用，且对有些分类属性的数据不适合。</li>
<li>要求用户必须事先给出要生成的簇的数目k。</li>
<li>对初值敏感，对于不同的初始值，可能会导致不同的聚类结果。</li>
<li>不适合于发现非凸面形状的簇，或者大小差别很大的簇。</li>
<li>对于&quot;噪声&quot;和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。</li>
</ul>
<p><strong>基于层次的聚类：</strong></p>
<p>自底向上的凝聚方法，比如AGNES。</p>
<p>自上向下的分裂方法，比如DIANA。</p>
<p><strong>基于密度的聚类：</strong></p>
<p>DBSACN,OPTICS,BIRCH(CF-Tree),CURE.</p>
<p><strong>基于网格的方法：</strong></p>
<p>STING, WaveCluster.</p>
<p><strong>基于模型的聚类：</strong></p>
<p>EM,SOM,COBWEB.</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB">机器学习分类</a>
<ul>
<li><a href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">监督学习：</a></li>
<li><a href="#%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">非监督学习：</a></li>
<li><a href="#%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0">半监督学习：</a></li>
<li><a href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0">强化学习：</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB">算法分类</a>
<ul>
<li><a href="#%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95">回归算法：</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%AE%97%E6%B3%95">基于实例的算法</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E5%8C%96%E6%96%B9%E6%B3%95">正则化方法</a></li>
<li><a href="#%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0">决策树学习</a></li>
<li><a href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95">贝叶斯方法</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%A0%B8%E7%9A%84%E7%AE%97%E6%B3%95">基于核的算法</a></li>
<li><a href="#%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95">聚类算法</a></li>
<li><a href="#%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">人工神经网络</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">深度学习</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3">常见算法优劣</a>
<ul>
<li><a href="#%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF"><strong>朴素贝叶斯：</strong></a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数表达式：</a></li>
<li><a href="#%E4%BC%98%E7%82%B9">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点：</a></li>
</ul>
</li>
<li><a href="#%E5%86%B3%E7%AD%96%E6%A0%91"><strong>决策树：</strong></a>
<ul>
<li><a href="#%E4%BF%A1%E6%81%AF%E7%86%B5%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">信息熵的函数表达式:</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-2">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-2">缺点：</a></li>
</ul>
</li>
<li><a href="#logistic%E5%9B%9E%E5%BD%92"><strong>Logistic回归：</strong></a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-2">函数表达式：</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-3">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-3">缺点：</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><strong>线性回归：</strong></a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-3">函数表达式:</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-4">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-4">缺点：</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95knn"><strong>最近邻算法(KNN)：</strong></a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9-5">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-5">缺点：</a></li>
</ul>
</li>
<li><a href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BAsvm"><strong>支持向量机(SVM)：</strong></a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-4">函数表达式：</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-6">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-6">缺点：</a></li>
</ul>
</li>
<li><a href="#%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95boosting">提升方法(Boosting)：</a>
<ul>
<li><a href="#adaboost%E7%9A%84%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><strong>Adaboost的简单版本训练过程：</strong></a></li>
<li><a href="#%E4%BC%98%E7%82%B9-7">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-7">缺点：</a></li>
</ul>
</li>
<li><a href="#%E8%81%9A%E7%B1%BB">聚类：</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-5">函数表达式:</a></li>
<li><a href="#%E4%BC%98%E7%82%B9-8">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-8">缺点：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/3PS50lCPb/">
                <span class="post-title">
                  有限元分析&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/urP3v4MnQ/">
              <span class="post-title">
                启发式算法&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>