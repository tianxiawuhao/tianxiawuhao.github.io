<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>PostgreSQL概述三 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="PostgreSQL概述三 | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="PostgreSQL概述三" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/uSSvVMkpS/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/WebMb8vrq/" class="tag">postgreSql</a>
                
              </span>
              <h1>PostgreSQL概述三</h1>
              <span class="meta">
                Posted on
                2023-04-15，24 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/uSSvVMkpS.png" alt="封面图">
          </img>
          
          <h2 id="十-事务">十、事务</h2>
<h3 id="101-什么是acid常识">10.1 什么是ACID？（常识）</h3>
<p>在日常操作中，对于一组相关操作，通常要求要么都成功，要么都失败。在关系型数据库中，称这一组操作为事务。为了保证整体事务的安全性，有ACID这一说：</p>
<ul>
<li>
<p>原子性A：事务是一个最小的执行单位，一次事务中的操作要么都成功，要么都失败。</p>
</li>
<li>
<p>一致性C：在事务完成时，所有数据必须保持在一致的状态。（事务完成后吗，最终结果和预期结果是一致的）</p>
</li>
<li>
<p>隔离性：一次事务操作，要么是其他事务操作前的状态，要么是其他事务操作后的状态，不存在中间状态。</p>
</li>
<li>
<p>持久性：事务提交后，数据会落到本地磁盘，修改是永久性的。</p>
</li>
</ul>
<p>PostgreSQL中，在事务的并发问题里，也是基于MVCC，多版本并发控制去维护数据的一致性。相比于传统的锁操作，MVCC最大的有点就是可以让<strong>读写互相不冲突 。</strong></p>
<p>当然，PostgreSQL也支持表锁和行锁，可以解决写写的冲突问题。</p>
<p>PostgreSQL相比于其他数据，有一个比较大的优化，DDL也可以包含在一个事务中。比如集群中的操作，一个事务可以保证多个节点都构建出一个表，才算成功。</p>
<h3 id="102-事务的基本使用">10.2 事务的基本使用</h3>
<p>首先基于前面的各种操作，应该已经体会到了，PostgreSQL是自动提交事务。跟MySQL是一样的。</p>
<p>可以基于关闭PostgreSQL的自动提交事务来进行操作。</p>
<figure data-type="image" tabindex="1"><img src="https://tianxiawuhao.github.io/post-images/9817bd8e8d7c57c21ab93e137343632c.png" alt="" loading="lazy"></figure>
<p>但是上述方式比较麻烦，传统的方式。</p>
<p>就是三个命令：</p>
<ul>
<li>
<p>begin：开始事务</p>
</li>
<li>
<p>commit：提交事务</p>
</li>
<li>
<p>rollback：回滚事务</p>
</li>
</ul>
<pre><code class="language-sql">-- 开启事务
begin;
-- 操作
insert into test values (7,'bbb',12,5);
-- 提交事务 
commit;
</code></pre>
<h3 id="103-保存点了解">10.3 保存点（了解）</h3>
<p>比如项目中有一个大事务操作，不好控制，超时有影响，回滚会造成一切重来，成本太高。</p>
<p>我针对大事务，拆分成几个部分，第一部分完成后，构建一个保存点。如果后面操作失败了，需要回滚，不需要全盘回滚，回滚到之前的保存点，继续重试。</p>
<p>有人会发现，破坏了整体事务的原子性。</p>
<p>But，只要操作合理，可以在保存点的举出上，做重试，只要重试不成功，依然可以全盘回滚。</p>
<p>比如一个电商项目，下订单，扣库存，创建订单，删除购物车，增加用户积分，通知商家…………。这个其实就是一个大事务。可以将扣库存和下订单这种核心功能完成后，增加一个保存点，如果说后续操作有失败的，可以从创建订单成功后的阶段，再做重试。</p>
<p>不过其实上述的业务，基于最终一致性有更好的处理方式，可以保证可用性。</p>
<p>简单操作一下。</p>
<pre><code class="language-sql">-- savepoint操作
-- 开启事务
begin;
-- 插入一条数据
insert into test values (8,'铃铛',55,11);
-- 添加一个保存点
savepoint ok1;
-- 再插入数据,比如出了一场
insert into test values (9,'大唐官府',66,22);
-- 回滚到之前的提交点
rollback to savepoint ok1;
-- 就可以开始重试操作，重试成功，commit，失败可以rollback;
commit;
</code></pre>
<h2 id="十一-并发问题">十一、并发问题</h2>
<h3 id="111-事务的隔离级别">11.1 事务的隔离级别</h3>
<p>在不考虑隔离性的前提下，事务的并发可能会出现的问题：</p>
<ul>
<li>
<p>脏读：读到了其他事务未提交的数据。（必须避免这种情况）</p>
</li>
<li>
<p>不可重复读：同一事务中，多次查询同一数据，结果不一致，因为其他事务修改造成的。（一些业务中这种不可重复读不是问题）</p>
</li>
<li>
<p>幻读：同一事务中，多次查询同一数据，因为其他事务对数据进行了增删吗，导致出现了一些问题。（一些业务中这种幻读不是问题）</p>
</li>
</ul>
<p>针对这些并发问题，关系型数据库有一些事务的隔离级别，一般用4种。</p>
<ul>
<li>
<p>READ UNCOMMITTED：读未提交（啥用没用，并且PGSQL没有，提供了只是为了完整性）</p>
</li>
<li>
<p>READ COMMITTED：读已提交，可以解决脏读（PGSQL默认隔离级别）</p>
</li>
<li>
<p>REPEATABLE READ：可重复读，可以解决脏读和不可重复读（MySQL默认是这个隔离级别，PGSQL也提供了，但是设置为可重复读，效果还是串行化）</p>
</li>
<li>
<p>SERIALIZABLE：串行化，啥都能解决（锁，效率慢）</p>
</li>
</ul>
<p>PGSQL在老版本中，只有两个隔离级别，读已提交和串行化。在PGSQL中就不存在脏读问题。</p>
<h3 id="112-mvcc">11.2 MVCC</h3>
<p>首先要清楚，为啥要有MVCC。</p>
<p>如果一个数据库，频繁的进行读写操作，为了保证安全，采用锁的机制。但是如果采用锁机制，如果一些事务在写数据，另外一个事务就无法读数据。会造成读写之间相互阻塞。 大多数的数据库都会采用一个机制 多版本并发控制 MVCC 来解决这个问题。</p>
<p>比如你要查询一行数据，但是这行数据正在被修改，事务还没提交，如果此时对这行数据加锁，会导致其他的读操作阻塞，需要等待。如果采用PostgreSQL，他的内部会针对这一行数据保存多个版本，如果数据正在被写入，包就保存之前的数据版本。让读操作去查询之前的版本，不需要阻塞。等写操作的事务提交了，读操作才能查看到最新的数据。 这几个及时可以确保 读写操作没有冲突 ，这个就是MVCC的主要特点。</p>
<p>写写操作，和MVCC没关系，那个就是加锁的方式！</p>
<p>Ps：这里的MVCC是基于 读已提交 去聊的，如果是串行化，那就读不到了。</p>
<p>在操作之前，先了解一下PGSQL中，每张表都会自带两个字段</p>
<ul>
<li>
<p>xmin：给当前事务分配的数据版本。如果有其他事务做了写操作，并且提交事务了，就给xmin分配新的版本。</p>
</li>
<li>
<p>xmax：当前事务没有存在新版本，xmax就是0。如果有其他事务做了写操作，未提交事务，将写操作的版本放到xmax中。提交事务后，xmax会分配到xmin中，然后xmax归0。</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://tianxiawuhao.github.io/post-images/71599c0cf131ecc03a5719a436aca28b.png" alt="" loading="lazy"></figure>
<p>基于上图的操作查看一波效果</p>
<p>事务A</p>
<pre><code class="language-sql">-- 左，事务A
--1、开启事务
begin;
--2、查询某一行数据,  xmin = 630,xmax = 0
select xmin,xmax,* from test where id = 8;
--3、每次开启事务后，会分配一个事务ID 事务id=631
select txid_current();
--7、修改id为8的数据，然后在本事务中查询   xmin = 631, xmax = 0
update test set name = '铃铛' where id = 8;
select xmin,xmax,* from test where id = 8;
--9、提交事务
commit;
</code></pre>
<p>事务B</p>
<pre><code class="language-sql">-- 右，事务B
--4、开启事务
begin;
--5、查询某一行数据,  xmin = 630,xmax = 0
select xmin,xmax,* from test where id = 8;
--6、每次开启事务后，会分配一个事务ID 事务id=632
select txid_current();
--8、事务A修改完，事务B再查询  xmin = 630  xmax = 631
select xmin,xmax,* from test where id = 8;
--10、事务A提交后，事务B再查询  xmin = 631  xmax = 0
select xmin,xmax,* from test where id = 8;
</code></pre>
<h2 id="十二-锁">十二、锁</h2>
<p>PostgreSQL中主要有两种锁，一个表锁一个行锁</p>
<p>PostgreSQL中也提供了页锁，咨询锁，But，这个不需要关注，他是为了锁的完整性</p>
<h3 id="121-表锁">12.1 表锁</h3>
<p>表锁显而易见，就是锁住整张表。表锁也分为很多中模式。</p>
<p>表锁的模式很多，其中最核心的两个：</p>
<ul>
<li>
<p>ACCESS SHARE：共享锁（读锁），读读操作不阻塞，但是不允许出现写操作并行</p>
</li>
<li>
<p>ACCESS EXCLUSIVE：互斥锁（写锁），无论什么操作进来，都阻塞。</p>
</li>
</ul>
<p>具体的可以查看官网文档：http://postgres.cn/docs/12/explicit-locking.html</p>
<p>表锁的实现：</p>
<p>先查看一波语法</p>
<figure data-type="image" tabindex="3"><img src="https://tianxiawuhao.github.io/post-images/f3a08903ec76e01654d22798757f333e.png" alt="" loading="lazy"></figure>
<p>就是基于LOCK开启表锁，指定表的名字name，其次在MODE中指定锁的模式，NOWAIT可以指定是否在没有拿到锁时，一致等待。</p>
<pre><code class="language-sql">-- 111号连接
-- 基于互斥锁，锁住test表
-- 先开启事务
begin;
-- 基于默认的ACCESS EXCLUSIVE锁住test表
lock test in ACCESS SHARE mode;
-- 操作
select * from test;
-- 提交事务，锁释放
commit;
</code></pre>
<p>当111号连接基于事务开启后，锁住当前表之后，如果使用默认的ACCESS EXCLUSIVE，其他连接操作表时，会直接阻塞住。</p>
<p>如果111号是基于ACCESS SHARE共享锁时，其他线程查询当前表是不会锁住得</p>
<h3 id="122-行锁">12.2 行锁</h3>
<p>PostgreSQL的行锁和MySQL的基本是一模一样的，基于select for update就可以指定行锁。</p>
<p>MySQL中有一个概念，for update时，如果select的查询没有命中索引，可能会锁表。</p>
<p>PostgerSQL有个特点，一般情况，在select的查询没有命中索引时，他不一定会锁表，依然会实现行锁。</p>
<p>PostgreSQL的行锁，就玩俩，一个for update，一个for share。<br>
在开启事务之后，直接执行select * from table where 条件 for update;</p>
<pre><code class="language-sql">-- 先开启事务
begin;
-- 基于for update 锁住id为3的数据
select * from test where id = 3 for update;
update test set name = 'v1' where id = 3;
-- 提交事务，锁释放
commit;
</code></pre>
<p>其他的连接要锁住当前行，会阻塞住。</p>
<h2 id="十三-备份恢复">十三、备份&amp;恢复</h2>
<p>防止数据丢失的第一道防线就是备份。数据丢失有的是硬件损坏，还有人为的误删之类的，也有BUG的原因导致误删数据。</p>
<p>正常备份和恢复，如果公司有DBA，一般咱们不用参与，BUT，学的Java，啥都得会点~~</p>
<p>在PostgreSQL中，有三种备份方式：</p>
<p><strong>SQL备份（逻辑备份）</strong> ：其实就是利用数据库自带的类似dump的命令，或者是你用图形化界面执行导入导出时，底层就是基于这个dump命令实现的。备份出来一份sql文件，谁需要就复制给谁。</p>
<ul>
<li>
<p>优点：简单，方便操作，有手就行，还挺可靠。</p>
</li>
<li>
<p>缺点：数据数据量比较大，这种方式巨慢，可能导出一天，都无法导出完所有数据。</p>
</li>
</ul>
<p><strong>文件系统备份（物理备份）</strong> ：其实就是找到当前数据库，数据文件在磁盘存储的位置，将数据文件直接复制一份或多份，存储在不同的物理机上，即便物理机爆炸一个，还有其他物理机。</p>
<ul>
<li>
<p>优点：相比逻辑备份，恢复的速度快。</p>
</li>
<li>
<p>缺点：在备份数据时，可能数据还正在写入，一定程度上会丢失数据。 在恢复数据时，也需要注意数据库的版本和环境必须保持高度的一致。如果是线上正在运行的数据库，这种复制的方式无法在生产环境实现。</p>
</li>
</ul>
<p>如果说要做数据的迁移，这种方式还不错滴。</p>
<p><strong>归档备份：（也属于物理备份）</strong></p>
<p>先了解几个概念，在PostgreSQL有多个子进程来辅助一些操作</p>
<ul>
<li>
<p>BgWriter进程：BgWriter是将内存中的数据写到磁盘中的一个辅助进程。当向数据库中执行写操作后，数据不会马上持久化到磁盘里。这个主要是为了提升性能。BgWriter会周期性的将内存中的数据写入到磁盘。但是这个周期时间，长了不行，短了也不行。<br>
如果快了，IO操作频繁，效率慢。<br>
如果慢了，有查询操作需要内存中的数据时，需要BgWriter现把数据从内存写到磁盘中，再提供给查询操作作为返回结果。会导致查询操作效率变低。<br>
考虑一个问题： 事务提交了，数据没落到磁盘，这时，服务器宕机了怎么办？</p>
</li>
<li>
<p>WalWriter进程：WAL就是write ahead log的缩写，说人话就是预写日志（redo log）。其实数据还在内存中时，其实已经写入到WAL日志中一份，这样一来，即便BgWriter进程没写入到磁盘中时，数据也不会存在丢失的问题。<br>
WAL能单独做备份么？单独不行！<br>
但是WAL日志有个问题，这个日志会循环使用，WAL日志有大小的线程，只能保存指定时间的日志信息，如果超过了，会覆盖之前的日志。</p>
</li>
<li>
<p>PgArch进程：WAL日志会循环使用，数据会丢失。没关系，还有一个归档的进程，会在切换wal日志前，将WAL日志备份出来。PostgreSQL也提供了一个全量备份的操作。可以根据WAL日志，选择一个事件点，进行恢复。<br>
查看一波WAL日志：</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://tianxiawuhao.github.io/post-images/5e73a90defe770f975ae6fdfac527644.png" alt="" loading="lazy"></figure>
<p>这些就是归档日志</p>
<pre><code class="language-sql">wal日志的名称，是三块内容组成，
每8个字符分成一组，用16进制标识的
00000001 00000000 0000000A
时间线 逻辑id 物理id
</code></pre>
<p>查询当前库用的是哪个wal日志</p>
<pre><code class="language-sql">-- 查看当前使用的wal日志  查询到的lsn：0/47233270
select pg_current_wal_lsn();
-- 基于lsn查询具体的wal日志名称  000000010000000000000047
select pg_walfile_name('0/47233270');
</code></pre>
<p>归档默认不是开启的，需要手动开启归档操作，才能保证wal日志的完整性</p>
<p>修改postgresql.conf文件</p>
<pre><code># 开启wal日志的内容，注释去掉即可
wal_level = replica
fsync = on
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://tianxiawuhao.github.io/post-images/c785e2fd561c23686b42609d7269a476.png" alt="" loading="lazy"></figure>
<pre><code># 开启归档操作
archive_mode = on
# 修改一小下命令，修改存放归档日志的路径
archive_command = 'test ! -f /archive/%f &amp;&amp; cp %p /archive/%f'
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://tianxiawuhao.github.io/post-images/d4eaa28e111e13a3d9f72d44f0619020.png" alt="" loading="lazy"></figure>
<p>修改完上述配置文件后，记得重启postgreSQL进程，才会生效！！！！</p>
<p>归档操作执行时，需要保证/archive存在，并且postgres用户有权限进行w操作</p>
<p>构建/archive路径</p>
<pre><code class="language-sql"># postgres没有权限在/目录下构建目录
# 切换到root，构建目录，将目录的拥有者更改为postgres
mkdir /archive
chown -R postgres. archive
</code></pre>
<p>在当前库中做大量写操作，接入到wal日志，重置切换wal日志，再查看归档情况</p>
<p>发现，将当前的正在使用的wal日志和最新的上一个wal日志归档过来了，但是之前的没归档，不要慌，后期备份时，会执行命令，这个命令会直接要求wal日志立即归档，然后最全量备份。</p>
<h3 id="131-逻辑备份恢复">13.1 逻辑备份&amp;恢复</h3>
<p>PostgreSQL提供了pg_dump以及pg_dumpall的命令来实现逻辑备份。</p>
<p>这两命令差不多，看名字猜！</p>
<p>pg_dump这种备份，不会造成用户对数据的操作出现阻塞。</p>
<p>数据库不是很大的时候，pg_dump也不是不成！</p>
<p>查看一波命令：</p>
<figure data-type="image" tabindex="7"><img src="https://tianxiawuhao.github.io/post-images/1909703e84e3a660abb9f0a8b72fbdd3.png" alt="" loading="lazy"></figure>
<p>这个命令从三块去看：http://postgres.cn/docs/12/app-pgdump.html</p>
<ul>
<li>
<p>连接的信息，指定连接哪个库，用哪个用户~</p>
</li>
<li>
<p>option的信息有就点多，查看官网。</p>
</li>
<li>
<p>备份的数据库！</p>
</li>
</ul>
<p>操作一波。</p>
<p>备份老郑库中的全部数据。</p>
<figure data-type="image" tabindex="8"><img src="https://tianxiawuhao.github.io/post-images/ed50b56a66c0782996074d3e91c2753c.png" alt="" loading="lazy"></figure>
<p>删除当前laozheng库中的表等信息，然后恢复数据</p>
<figure data-type="image" tabindex="9"><img src="https://tianxiawuhao.github.io/post-images/be0f3928831e24ec0733909cc77fef13.png" alt="" loading="lazy"></figure>
<p>除此之外，也可以通过图形化界面备份，在库的位置点击备份就成，导出一个文本文件。</p>
<h3 id="132-物理备份归档物理">13.2 物理备份（归档+物理）</h3>
<p>这里需要基于前面的文件系统的备份和归档备份实现最终的操作</p>
<p>单独使用文件系统的方式，不推荐毕竟数据会丢失。</p>
<p>这里直接上PostgreSQL提供的pg_basebackup命令来实现。</p>
<p>pg_basebackup会做两个事情、</p>
<ul>
<li>
<p>会将内存中的脏数据落到磁盘中，然后将数据全部备份</p>
</li>
<li>
<p>会将wal日志直接做归档，然后将归档也备走。</p>
</li>
</ul>
<p>查看一波pg_basebackup命令</p>
<figure data-type="image" tabindex="10"><img src="https://tianxiawuhao.github.io/post-images/92841ec3a296ae1dd247f765cc51570c.png" alt="" loading="lazy"></figure>
<p>先准备一个pg_basebackup的备份命令</p>
<pre><code># -D 指定备份文件的存储位置
# -Ft 备份文件打个包
# -Pv 输出备份的详细信息
# -U 用户名（要拥有备份的权限）
# -h ip地址  -p 端口号
# -R 复制写配置文件
pg_basebackup -D /pg_basebackup -Ft -Pv -Upostgres -h 192.168.11.32 -p 5432 -R
</code></pre>
<p>准备测试，走你~</p>
<p>提前准备出/pg_basebackup目录。记得将拥有者赋予postgres用户</p>
<pre><code class="language-sql">mkdir /pg_basebackup
chown -R postgres. /pg_basebackup/
</code></pre>
<p>给postgres用户提供replication的权限，修改pg_hba.conf，记得重启生效</p>
<figure data-type="image" tabindex="11"><img src="https://tianxiawuhao.github.io/post-images/7e45c3f77d539d72d1170577a37d45a8.png" alt="" loading="lazy"></figure>
<p>执行备份</p>
<pre><code class="language-sql">pg_basebackup -D /pg_basebackup -Ft -Pv -Upostgres -h 192.168.11.32 -p 5432 -R
</code></pre>
<p>需要输入postgres的密码，这里可以设置，重新备份。</p>
<figure data-type="image" tabindex="12"><img src="https://tianxiawuhao.github.io/post-images/9a06068bc1052258712861533b87e1ea.png" alt="" loading="lazy"></figure>
<p>执行备份</p>
<figure data-type="image" tabindex="13"><img src="https://tianxiawuhao.github.io/post-images/8ff100ada45842be6820c5cca82a897f.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://tianxiawuhao.github.io/post-images/9a2626c864067020850546b94bf77d2e.png" alt="" loading="lazy"></figure>
<h3 id="133-物理恢复归档物理">13.3 物理恢复（归档+物理）</h3>
<p>模拟数据库崩盘，先停止postgresql服务，然后直接删掉data目录下的全部内容</p>
<figure data-type="image" tabindex="15"><img src="https://tianxiawuhao.github.io/post-images/83573409eaef8562c37927dadd85c6d6.png" alt="" loading="lazy"></figure>
<p>将之前备份的两个文件准备好，一个base.tar，一个pg_wal.tar</p>
<p>第一步：将base.tar中的内容，全部解压到 12/data 目录下</p>
<p>第二步：将pg_wal.tar中的内容，全部解压到 /archive 目录下</p>
<figure data-type="image" tabindex="16"><img src="https://tianxiawuhao.github.io/post-images/b2253ca807c7da794d40e7fcb4e3849b.png" alt="" loading="lazy"></figure>
<p>第三步：在postgresql.auto.conf文件中，指定归档文件的存储位置，以及恢复数据的方式</p>
<figure data-type="image" tabindex="17"><img src="https://tianxiawuhao.github.io/post-images/d1163e6f78df134a3db3959112a62473.png" alt="" loading="lazy"></figure>
<p>第四步：启动postgresql服务</p>
<pre><code>systemctl start postgresql-12
</code></pre>
<p>第五步：启动后，发现查询没问题，但是执行写操作时，出错，不让写。需要执行一个函数，取消这种恢复数据后的状态，才允许正常的执行写操作。</p>
<pre><code>select pg_wal_replay_resume();
</code></pre>
<h3 id="134-物理备份恢复pitr-point-in-time-recovery">13.4 物理备份&amp;恢复（PITR-Point in time Recovery）</h3>
<p>模拟场景</p>
<blockquote>
<p>场景：每天凌晨02:00，开始做全备（PBK），到了第二天，如果有人14:00分将数据做了误删，希望将数据恢复到14:00分误删之前的状态？</p>
</blockquote>
<p>1、恢复全备数据，使用PBK的全备数据恢复到凌晨02:00的数据。（数据会丢失很多）</p>
<p>2、归档恢复：备份中的归档，有02:00~14:00之间的额数据信息，可以基于归档日志将数据恢复到指定的事务id或者是指定时间点，从而实现数据的完整恢复。</p>
<p>准备场景和具体操作<br>
<strong>1、构建一张t3表查询一些数据</strong></p>
<pre><code>-- 构建一张表
create table t3 (id int);
insert into t3 values (1);
insert into t3 values (11);
</code></pre>
<p><strong>2、模拟凌晨2点开始做全备操作</strong></p>
<pre><code class="language-sql">pg_basebackup -D /pg_basebackup -Ft -Pv -Upostgres -h 192.168.11.32 -p 5432 -R
</code></pre>
<p><strong>3、再次做一些写操作，然后误删数据</strong></p>
<pre><code class="language-sql">-- 凌晨2点已经全备完毕
-- 模拟第二天操作
insert into t3 values (111);
insert into t3 values (1111);
-- 误删操作  2023年3月20日20:13:26
delete from t3;
</code></pre>
<p><strong>4、恢复数据（确认有归档日志）</strong></p>
<p>将当前服务的数据全部干掉，按照之前的全备恢复的套路先走着</p>
<figure data-type="image" tabindex="18"><img src="https://tianxiawuhao.github.io/post-images/7a5c029f8090df4ba6cabf7e9ca85281.png" alt="" loading="lazy"></figure>
<p>然后将全备的内容中的base.tar扔data目录下，归档日志也扔到/archive位置。</p>
<p><strong>5、查看归档日志，找到指定的事务id</strong></p>
<p>查看归档日志，需要基于postgresql提供的一个命令</p>
<pre><code class="language-sql"># 如果命令未找到，说明两种情况，要么没有这个可执行文件，要么是文件在，没设置环境变量
# 咱们这是后者
pg_waldump
# 也可以采用全路径的方式
/usr/pgsql-12/bin/pg_waldump
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://tianxiawuhao.github.io/post-images/2ce78b31e22af1855f50a21da1bca816.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://tianxiawuhao.github.io/post-images/2e75aa473986cfbadbc1303e79ddc6ca.png" alt="" loading="lazy"></figure>
<p><strong>6、修改data目录下的恢复数据的方式</strong></p>
<p>修改postgresql.auto.conf文件</p>
<p>将之前的最大恢复，更换为指定的事务id恢复</p>
<p>基于提供的配置例子，如何指定事务id</p>
<figure data-type="image" tabindex="21"><img src="https://tianxiawuhao.github.io/post-images/b7b8ee0cda00484b9e50e8a4391d107a.png" alt="" loading="lazy"></figure>
<p>修改postgresql.auto.conf文件指定好事务ID</p>
<figure data-type="image" tabindex="22"><img src="https://tianxiawuhao.github.io/post-images/010acf7a6352154e3215285e5ad73e78.png" alt="" loading="lazy"></figure>
<p>7、启动postgreSQL服务，查看是否恢复到指定事务ID</p>
<figure data-type="image" tabindex="23"><img src="https://tianxiawuhao.github.io/post-images/dd42a0c10819678855d480c029cf0afe.png" alt="" loading="lazy"></figure>
<p>8、记得执行会后的函数，避免无法执行写操作</p>
<pre><code>select pg_wal_replay_resume();
</code></pre>
<h2 id="十四-数据迁移">十四、数据迁移</h2>
<p>PostgreSQL做数据迁移的插件非常多，可以从MySQL迁移到PostgreSQL也可以基于其他数据源迁移到PostgreSQL</p>
<p>这种迁移的插件很多，这里只说一个，pgloader（巨方便）</p>
<p>以MySQL数据迁移到PostgreSQL为例，分为几个操作：</p>
<ul>
<li>1、准备MySQL服务（防火墙问题，远程连接问题，权限问题）</li>
</ul>
<p>准备了一个sms_platform的库，里面大概有26W条左右的数据</p>
<ul>
<li>
<p>2、准备PostgreSQL的服务（使用当前一直玩的PostgreSQL）</p>
</li>
<li>
<p>3、安装pgloader</p>
</li>
</ul>
<p>pgloader可以安装在任何位置，比如安装在MySQL所在服务，或者PostgreSQL所在服务，再或者一个独立的服务都可以</p>
<p>我就在PostgreSQL所在服务安装</p>
<pre><code class="language-shell"># 用root用户下载
yum -y install pgloader
</code></pre>
<ul>
<li>4、准备pgloader需要的脚本文件</li>
</ul>
<p>官方文档： https://pgloader.readthedocs.io/en/latest/</p>
<p>记住，PostgreSQL的数据库需要提前构建好才可以！！！！</p>
<figure data-type="image" tabindex="24"><img src="https://tianxiawuhao.github.io/post-images/d7472a32c13b5d92456a8cf8e19516d1.png" alt="" loading="lazy"></figure>
<ul>
<li>5、执行脚本，完成数据迁移</li>
</ul>
<p>先确认pgloader命令可以使用</p>
<figure data-type="image" tabindex="25"><img src="https://tianxiawuhao.github.io/post-images/b9f7fdf550f75f0a63291ba252ddd30f.png" alt="" loading="lazy"></figure>
<p>执行脚本：</p>
<pre><code class="language-shell">pgloader 刚刚写好的脚本文件
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://tianxiawuhao.github.io/post-images/7c832e36556633abed45289ef01d1d23.png" alt="" loading="lazy"></figure>
<h2 id="十五-主从操作">十五、主从操作</h2>
<p>PostgreSQL自身只支持简单的主从，没有主从自动切换，仿照类似Nginx的效果一样，采用keepalived的形式，在主节点宕机后，通过脚本的执行完成主从切换。</p>
<h3 id="151-主从实现异步流复制">15.1 主从实现（异步流复制）</h3>
<p>操作方式类似与之前的备份和恢复</p>
<p>**1、准备环境：**准备两台虚拟机，完成上述的环境准备</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>IP</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Master</td>
<td>192.168.11.66</td>
<td>5432</td>
</tr>
<tr>
<td>Standby</td>
<td>192.168.11.67</td>
<td>5432</td>
</tr>
</tbody>
</table>
<p>修改好ip，安装好postgresql服务</p>
<p><strong>2、给主准备一些数据</strong></p>
<pre><code class="language-sql">create table t1 (id int);
insert into t1 values (111);
select * from t1;
</code></pre>
<p><strong>3、配置主节点信息（主从都配置，因为后面会有主从切换的操作）</strong><br>
修改 pg_hba.conf 文件</p>
<figure data-type="image" tabindex="27"><img src="https://tianxiawuhao.github.io/post-images/34cfba01979b47a6227cbd2095e580eb.png" alt="" loading="lazy"></figure>
<p>修改 postgresql.conf 文件</p>
<figure data-type="image" tabindex="28"><img src="https://tianxiawuhao.github.io/post-images/e5727f39ca732080139ead42de5b8704.png" alt="" loading="lazy"></figure>
<p>提前构建好归档日志和备份目录，并且设置好拥有者</p>
<figure data-type="image" tabindex="29"><img src="https://tianxiawuhao.github.io/post-images/868b4ee2eeec7b55a60878833b4bb51d.png" alt="" loading="lazy"></figure>
<p>重启PostgreSQL服务</p>
<pre><code class="language-sql">systemctl restart postgresql-12
</code></pre>
<p>4、从节点加入到主节点<br>
关闭从节点服务</p>
<pre><code class="language-sql">systemctl stop postgresql-12
</code></pre>
<p>删除从节点数据（删除data目录）</p>
<pre><code class="language-sql">rm -rf ~/12/data/*
</code></pre>
<p>基于pbk去主节点备份数据</p>
<pre><code class="language-sql"># 确认好备份的路径，还有主节点的ip
pg_basebackup -D /pgbasebackup -Ft -Pv -Upostgres -h 192.168.11.66 -p 5432 -R
</code></pre>
<p>恢复数据操作，解压tar包</p>
<pre><code class="language-sql">cd /pgbasebackuo
tar -xf base.tar -C ~/12/data
tar -xf pg_wal.tar -C /archive
</code></pre>
<p>修改postgresql.auto.conf文件</p>
<pre><code class="language-sql"># 确认有这两个配置，一般第一个需要手写，第二个会自动生成

restore_command = 'cp /archive/%f %p'
primary_conninfo = 'user=postgres password=postgres host=192.168.11.66 port=5432 sslmode=prefer sslcompression=0 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
</code></pre>
<p>修改standby.signal文件，开启从节点备份模式</p>
<pre><code class="language-sql"># 开启从节点备份

standby_mode = 'on'
</code></pre>
<p>启动从节点服务</p>
<pre><code>systemctl restart postgresql-12
</code></pre>
<p>查看主从信息</p>
<p>查看从节点是否有t1表</p>
<ul>
<li>
<p>主节点添加一行数据，从节点再查询，可以看到最新的数据</p>
</li>
<li>
<p>从节点无法完成写操作，他是只读模式</p>
</li>
<li>
<p>主节点查看从节点信息</p>
<pre><code class="language-sql">select * from pg_stat_replication
</code></pre>
</li>
<li>
<p>从节点查看主节点信息</p>
<pre><code class="language-sql">select * from pg_stat_wal_receiver
</code></pre>
</li>
</ul>
<p>15.2 主从切换（不这么玩）<br>
其实主从的本质就是从节点去主节点不停的备份新的数据。</p>
<p>配置文件的系统其实就是两个：</p>
<ul>
<li>
<p>standby.signal文件，这个是从节点开启备份</p>
</li>
<li>
<p>postgresql.auto.conf文件，这个从节点指定主节点的地址信息</p>
</li>
</ul>
<p>切换就是原主追加上述配置，原从删除上述配追</p>
<ul>
<li>
<p>1、主从节点全部stop停止：………………</p>
</li>
<li>
<p>2、原从删除上述配置：…………</p>
</li>
<li>
<p>3、原从新主启动服务：………</p>
</li>
<li>
<p>4、原主新从去原从新主备份一次数据：pg_basebackup操作，同时做解压，然后修改postgresql.conf文件以及standby.signal配置文件</p>
</li>
<li>
<p>5、启动原主新从查看信息</p>
</li>
</ul>
<h3 id="153-主从故障切换">15.3 主从故障切换</h3>
<p>默认情况下，这里的主从备份是异步的，导致一个问题，如果主节点写入的数据还没有备份到从节点，主节点忽然宕机了，导致后面如果基于上述方式实现主从切换，数据可能丢失。</p>
<p>PGSQL在9.5版本后提供了一个pg_rewind的操作，基于归档日志帮咱们做一个比对，比对归档日志，是否有时间差冲突。</p>
<p>实现操作：</p>
<ul>
<li>1、rewind需要开启一项配置才可以使用</li>
</ul>
<p>修改postgresql.conf中的 wal_log_hints = ‘on’</p>
<ul>
<li>2、为了可以更方便的使用rewind，需要设置一下 /usr/pgsql-12/bin/ 的环境变量</li>
</ul>
<pre><code class="language-sql">vi /etc/profile
  追加信息
  export PATH=/usr/pgsql-12/bin/:$PATH
source /etc/profile
</code></pre>
<ul>
<li>
<p>3、模拟主库宕机，直接对主库关机</p>
</li>
<li>
<p>4、从节点切换为主节点</p>
</li>
</ul>
<pre><code class="language-sql"># 因为他会去找$PGDATA，我没配置，就基于-D指定一下PGSQL的data目录

pg_ctl promote -D ~/12/data/
</code></pre>
<ul>
<li>5、将原主节点开机，执行命令，搞定归档日志的同步</li>
</ul>
<p>启动虚拟机<br>
停止PGSQL服务</p>
<pre><code class="language-sql">pg_ctl stop -D ~/12/data
</code></pre>
<p>基于pg_rewind加入到集群</p>
<pre><code class="language-sql">pg_rewind -D ~/12/data/ --source-server='host=192.168.11.66 user=postgres password=postgres'
</code></pre>
<p>如果上述命令失败，需要启动再关闭PGSQL，并且在执行，完成归档日志的同步</p>
<pre><code class="language-sql">pg_ctl start -D ~/12/data
pg_ctl stop -D ~/12/data
pg_rewind -D ~/12/data/ --source-server='host=192.168.11.66 user=postgres password=postgres'
</code></pre>
<ul>
<li>6、修改新从节点的配置，然后启动</li>
</ul>
<p>构建standby.signal</p>
<pre><code>standby_mode = 'on'
</code></pre>
<p>修改postgresql.auto.conf文件</p>
<pre><code class="language-sql"># 注意ip地址

primary_conninfo = 'user=postgres password=postgres host=192.168.11.66 port=5432 sslmode=prefer sslcompression=0 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
restore_command = 'cp /archive/%f %p'
</code></pre>
<p>启动新的从节点</p>
<pre><code>pg_ctl start -D ~/12/data/
</code></pre>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%8D%81-%E4%BA%8B%E5%8A%A1">十、事务</a>
<ul>
<li><a href="#101-%E4%BB%80%E4%B9%88%E6%98%AFacid%E5%B8%B8%E8%AF%86">10.1 什么是ACID？（常识）</a></li>
<li><a href="#102-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">10.2 事务的基本使用</a></li>
<li><a href="#103-%E4%BF%9D%E5%AD%98%E7%82%B9%E4%BA%86%E8%A7%A3">10.3 保存点（了解）</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">十一、并发问题</a>
<ul>
<li><a href="#111-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">11.1 事务的隔离级别</a></li>
<li><a href="#112-mvcc">11.2 MVCC</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E9%94%81">十二、锁</a>
<ul>
<li><a href="#121-%E8%A1%A8%E9%94%81">12.1 表锁</a></li>
<li><a href="#122-%E8%A1%8C%E9%94%81">12.2 行锁</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89-%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D">十三、备份&amp;恢复</a>
<ul>
<li><a href="#131-%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D">13.1 逻辑备份&amp;恢复</a></li>
<li><a href="#132-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E5%BD%92%E6%A1%A3%E7%89%A9%E7%90%86">13.2 物理备份（归档+物理）</a></li>
<li><a href="#133-%E7%89%A9%E7%90%86%E6%81%A2%E5%A4%8D%E5%BD%92%E6%A1%A3%E7%89%A9%E7%90%86">13.3 物理恢复（归档+物理）</a></li>
<li><a href="#134-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8Dpitr-point-in-time-recovery">13.4 物理备份&amp;恢复（PITR-Point in time Recovery）</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%9B%9B-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB">十四、数据迁移</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-%E4%B8%BB%E4%BB%8E%E6%93%8D%E4%BD%9C">十五、主从操作</a>
<ul>
<li><a href="#151-%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%B5%81%E5%A4%8D%E5%88%B6">15.1 主从实现（异步流复制）</a></li>
<li><a href="#153-%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2">15.3 主从故障切换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/ZZ6BztHhQ/">
                <span class="post-title">
                  基于PostgreSQL的时序数据库TimescaleDB的基本用法和概念&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/IKbaKSlgE/">
              <span class="post-title">
                PostgreSQL概述二&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>