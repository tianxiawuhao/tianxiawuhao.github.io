<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>第十章 Table API 与 SQL | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="第十章 Table API 与 SQL | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="第十章 Table API 与 SQL" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/tloS_nSAM/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/seQXl0jPasu/" class="tag">flink</a>
                
              </span>
              <h1>第十章 Table API 与 SQL</h1>
              <span class="meta">
                Posted on
                2021-04-17，19 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/tloS_nSAM.png" alt="封面图">
          </img>
          
          <h2 id="table-api-sql-介绍">Table API &amp; SQL 介绍</h2>
<h3 id="11-flink-table模块">1.1 Flink Table模块</h3>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/</p>
</blockquote>
<p>Flink的Table模块包括 Table API和 SQL：</p>
<ul>
<li>
<p>Table API： 是一种类SQL的API，通过Table API，用户可以像操作表一样操作数据，非常直观和方便；</p>
</li>
<li>
<p>SQL：作为一种声明式语言，有着标准的语法和规范，用户可以不用关心底层实现即可进行数据的处理，非常易于上手。<br>
Flink Table API 和 SQL 的实现上有80%左右的代码是公用的。作为一个流批统一的计算引擎，Flink 的 Runtime 层是统一的。</p>
</li>
</ul>
<h3 id="12-table-api-sql特点">1.2 Table API &amp; SQL特点</h3>
<p>Flink之所以选择将 Table API &amp; SQL作为未来的核心 API，是因为其具有一些非常重要的特点：</p>
<ul>
<li>
<p>声明式：用户只关心做什么，不用关心怎么做</p>
</li>
<li>
<p>高性能：支持查询优化，可以获取更好的执行性能</p>
</li>
<li>
<p>批流统一：相同的统计逻辑，既可以流模式运行，也可以批模式运行</p>
</li>
<li>
<p>标准稳定：语义遵循SQL标准，不易变动</p>
</li>
<li>
<p>易理解：语义明确，所见即所得</p>
</li>
</ul>
<p><strong>使用举例：</strong></p>
<table>
<thead>
<tr>
<th>Table API</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>tab.groupBy(“word”).select(&quot;word,count(1) as count&quot;)</td>
<td>SELECT word,COUNT(*) AS cnt FROM MyTable GROUP BY word</td>
</tr>
</tbody>
</table>
<h3 id="13-table-api-sql发展历程">1.3 Table API&amp; SQL发展历程</h3>
<p>自 2015 年开始，阿里巴巴开始调研开源流计算引擎，最终决定基于 Flink 打造新一代计算引擎，针对 Flink存在的不足进行优化和改进，并且在 2019 年初将最终代码开源，也就是Blink。</p>
<p><code>Blink 在原来的 Flink 基础上最显著的一个贡献就是 Flink SQL的实现！</code></p>
<p><strong>架构升级：</strong></p>
<p>查询处理器的选择 ： <code>Flink1.11</code>之后<code>Blink Query Processor</code>查询处理器已经是默认的了。</p>
<h2 id="03-开发准备">03 开发准备</h2>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/</p>
</blockquote>
<h3 id="21-添加依赖">2.1 添加依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-table-api-scala-bridge_2.12&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-table-api-java-bridge_2.12&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- flink执行计划,这是1.9版本之前的--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-table-planner_2.12&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- blink执行计划,1.11+默认的--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-table-planner-blink_2.12&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;
    &lt;artifactId&gt;flink-table-common&lt;/artifactId&gt;
    &lt;version&gt;${flink.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>解析：</p>
<ul>
<li>
<p>flink-table-common：这个包中主要是包含 Flink Planner和 Blink Planner一些共用的代码。</p>
</li>
<li>
<p>flink-table-api-java：这部分是用户编程使用的 API，包含了大部分的API。</p>
</li>
<li>
<p>flink-table-api-scala：这里只是非常薄的一层，仅和 Table API的 Expression 和 DSL 相关。</p>
</li>
<li>
<p>两个 Planner：flink-table-planner和 flink-table-planner-blink。</p>
</li>
<li>
<p>两个 Bridge：flink-table-api-scala-bridge 和 flink-table-api-java-bridge</p>
</li>
</ul>
<p>Flink Planner 和 Blink Planner 都会依赖于具体的 JavaAPI，也会依赖于具体的 Bridge，通过Bridge可以将 API 操作相应的转化为Scala的 DataStream，或者转化为JAVA的 DataStream</p>
<h3 id="22-程序结构">2.2 程序结构</h3>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/common.html#structure-of-table-api-and-sql-programs</p>
</blockquote>
<pre><code class="language-java">// create a TableEnvironment for specific planner batch or streaming
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// create a Table
tableEnv.connect(...).createTemporaryTable(&quot;table1&quot;);
// register an output Table
tableEnv.connect(...).createTemporaryTable(&quot;outputTable&quot;);

// create a Table object from a Table API query
Table tapiResult = tableEnv.from(&quot;table1&quot;).select(...);

// create a Table object from a SQL query
Table sqlResult  = tableEnv.sqlQuery(&quot;SELECT ... FROM table1 ... &quot;);

// emit a Table API result Table to a TableSink, same for SQL result
TableResult tableResult = tapiResult.executeInsert(&quot;outputTable&quot;);
tableResult...
</code></pre>
<h3 id="23-api">2.3 API</h3>
<h4 id="231-获取环境">2.3.1 获取环境</h4>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/common.html#create-a-tableenvironment</p>
</blockquote>
<pre><code class="language-java">// **********************
// FLINK STREAMING QUERY
// **********************
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

EnvironmentSettings fsSettings = EnvironmentSettings.newInstance().useOldPlanner().inStreamingMode().build();
StreamExecutionEnvironment fsEnv = StreamExecutionEnvironment.getExecutionEnvironment();
StreamTableEnvironment fsTableEnv = StreamTableEnvironment.create(fsEnv, fsSettings);
// or TableEnvironment fsTableEnv = TableEnvironment.create(fsSettings);

// ******************
// FLINK BATCH QUERY
// ******************
import org.apache.flink.api.java.ExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.BatchTableEnvironment;

ExecutionEnvironment fbEnv = ExecutionEnvironment.getExecutionEnvironment();
BatchTableEnvironment fbTableEnv = BatchTableEnvironment.create(fbEnv);

// **********************
// BLINK STREAMING QUERY
// **********************
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

StreamExecutionEnvironment bsEnv = StreamExecutionEnvironment.getExecutionEnvironment();
EnvironmentSettings bsSettings = EnvironmentSettings.newInstance().useBlinkPlanner().inStreamingMode().build();
StreamTableEnvironment bsTableEnv = StreamTableEnvironment.create(bsEnv, bsSettings);
// or TableEnvironment bsTableEnv = TableEnvironment.create(bsSettings);

// ******************
// BLINK BATCH QUERY
// ******************
import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.TableEnvironment;

EnvironmentSettings bbSettings = EnvironmentSettings.newInstance().useBlinkPlanner().inBatchMode().build();
TableEnvironment bbTableEnv = TableEnvironment.create(bbSettings);
</code></pre>
<h4 id="233-创建表">2.3.3 创建表</h4>
<pre><code class="language-java">// get a TableEnvironment
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// table is the result of a simple projection query
Table projTable = tableEnv.from(&quot;X&quot;).select(...);

// register the Table projTable as table &quot;projectedTable&quot;
tableEnv.createTemporaryView(&quot;projectedTable&quot;, projTable);
</code></pre>
<pre><code class="language-java">tableEnvironment
  .connect(...)
  .withFormat(...)
  .withSchema(...)
  .inAppendMode()
  .createTemporaryTable(&quot;MyTable&quot;)
</code></pre>
<h4 id="234-查询表">2.3.4 查询表</h4>
<pre><code class="language-java">Table API：

// get a TableEnvironment
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// register Orders table
// scan registered Orders table
Table orders = tableEnv.from(&quot;Orders&quot;);// compute revenue for all customers from France
Table revenue = orders
  .filter($(&quot;cCountry&quot;)
  .isEqual(&quot;FRANCE&quot;))
  .groupBy($(&quot;cID&quot;), $(&quot;cName&quot;)
  .select($(&quot;cID&quot;), $(&quot;cName&quot;), $(&quot;revenue&quot;)
.sum()
.as(&quot;revSum&quot;));
// emit or convert Table
// execute query
</code></pre>
<p><strong>SQL：</strong></p>
<pre><code class="language-java">// get a TableEnvironment
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// register Orders table
// compute revenue for all customers from France
Table revenue = tableEnv.sqlQuery(
    &quot;SELECT cID, cName, SUM(revenue) AS revSum &quot; +
    &quot;FROM Orders &quot; +
    &quot;WHERE cCountry = 'FRANCE' &quot; +
    &quot;GROUP BY cID, cName&quot;
  );
// emit or convert Table
// execute query
</code></pre>
<pre><code class="language-java">// get a TableEnvironment
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// register &quot;Orders&quot; table
// register &quot;RevenueFrance&quot; output table
// compute revenue for all customers from France and emit to &quot;RevenueFrance&quot;
tableEnv.executeSql(
    &quot;INSERT INTO RevenueFrance &quot; +
    &quot;SELECT cID, cName, SUM(revenue) AS revSum &quot; +
    &quot;FROM Orders &quot; +
    &quot;WHERE cCountry = 'FRANCE' &quot; +
    &quot;GROUP BY cID, cName&quot;
  );
</code></pre>
<h4 id="235-写出表">2.3.5 写出表</h4>
<pre><code class="language-java">// get a TableEnvironment
TableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section
// create an output Table
final Schema schema = new Schema()
    .field(&quot;a&quot;, DataTypes.INT())
    .field(&quot;b&quot;, DataTypes.STRING())
    .field(&quot;c&quot;, DataTypes.BIGINT());
tableEnv.connect(new FileSystem().path(&quot;/path/to/file&quot;))
    .withFormat(new Csv().fieldDelimiter('|').deriveSchema())
    .withSchema(schema)
    .createTemporaryTable(&quot;CsvSinkTable&quot;);
// compute a result Table using Table API operators and/or SQL queries
Table result = ...
// emit the result Table to the registered TableSink
result.executeInsert(&quot;CsvSinkTable&quot;);
</code></pre>
<h4 id="236-与datastream集成">2.3.6 与DataStream集成</h4>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/common.html#integration-with-datastream-and-dataset-api</p>
</blockquote>
<h5 id="3361-从datastream创建视图">3.3.6.1 从DataStream创建视图</h5>
<pre><code class="language-java">Create a View from a DataStream or DataSet：

// get StreamTableEnvironment
// registration of a DataSet in a BatchTableEnvironment is equivalent
StreamTableEnvironment tableEnv = ...;

// see &quot;Create a TableEnvironment&quot; section
DataStream&lt;Tuple2&lt;Long, String&gt;&gt; stream = ...

// register the DataStream as View &quot;myTable&quot; with fields &quot;f0&quot;, &quot;f1&quot;
tableEnv.createTemporaryView(&quot;myTable&quot;, stream);

// register the DataStream as View &quot;myTable2&quot; with fields &quot;myLong&quot;, &quot;myString&quot;
tableEnv.createTemporaryView(&quot;myTable2&quot;, stream, $(&quot;myLong&quot;), $(&quot;myString&quot;));
</code></pre>
<h5 id="2362-转换datastream到表">2.3.6.2 转换DataStream到表</h5>
<pre><code class="language-java">Convert a DataStream or DataSet into a Table：

// get StreamTableEnvironment// registration of a DataSet in a BatchTableEnvironment is equivalent
StreamTableEnvironment tableEnv = ...;
// see &quot;Create a TableEnvironment&quot; section

DataStream&lt;Tuple2&lt;Long, String&gt;&gt; stream = ...
// Convert the DataStream into a Table with default fields &quot;f0&quot;, &quot;f1&quot;

Table table1 = tableEnv.fromDataStream(stream);
// Convert the DataStream into a Table with fields &quot;myLong&quot;, &quot;myString&quot;
Table table2 = tableEnv.fromDataStream(stream, $(&quot;myLong&quot;), $(&quot;myString&quot;));
</code></pre>
<h5 id="2363-转换表到datastream">2.3.6.3 转换表到DataStream</h5>
<p><strong>Convert a Table into a DataStream：</strong></p>
<ul>
<li>
<p>追加模式（Append Mode）：只有当动态表仅通过插入更改进行修改时，才能使用此模式，即，它是仅追加模式，并且以前发出的结果从不更新；</p>
</li>
<li>
<p>撤回模式（Retract Mode）：此模式始终可用。它使用布尔标志对插入和删除更改进行编码。</p>
</li>
</ul>
<pre><code class="language-java">// get StreamTableEnvironment.
StreamTableEnvironment tableEnv = ...; // see &quot;Create a TableEnvironment&quot; section

// Table with two fields (String name, Integer age)
Table table = ...

// convert the Table into an append DataStream of Row by specifying the class
DataStream&lt;Row&gt; dsRow = tableEnv.toAppendStream(table, Row.class);

// convert the Table into an append DataStream of Tuple2&lt;String, Integer&gt;
 //   via a TypeInformation
TupleTypeInfo&lt;Tuple2&lt;String, Integer&gt;&gt; tupleType = new TupleTypeInfo&lt;&gt;(
  Types.STRING(),
  Types.INT());
DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dsTuple =
  tableEnv.toAppendStream(table, tupleType);
// convert the Table into a retract DataStream of Row.
//   A retract stream of type X is a DataStream&lt;Tuple2&lt;Boolean, X&gt;&gt;.
//   The boolean field indicates the type of the change.
//   True is INSERT, false is DELETE.
DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; retractStream =
  tableEnv.toRetractStream(table, Row.class);
</code></pre>
<h4 id="237-tableapi">2.3.7 TableAPI</h4>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/tableApi.html</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src=".%5CSnipaste_2023-04-12_10-13-06.png" alt="" loading="lazy"></figure>
<h4 id="238-sql">2.3.8 SQL</h4>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/sql/</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src=".%5CSnipaste_2023-04-12_10-13-24.png" alt="" loading="lazy"></figure>
<h2 id="03-相关概念">03 相关概念</h2>
<blockquote>
<p>参考：https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/table/streaming/dynamic_tables.html</p>
</blockquote>
<h3 id="31-动态表和连续查询">3.1 动态表和连续查询</h3>
<p>在Flink中，它把针对无界流的表称之为Dynamic Table（动态表）。它是Flink Table API和SQL的核心概念，顾名思义，它表示了Table是不断变化的。</p>
<p>我们可以这样来理解，当我们用Flink的API，建立一个表，其实把它理解为建立一个逻辑结构，这个逻辑结构需要映射到数据上去。</p>
<p>Flink source源源不断的流入数据，就好比每次都往表上新增一条数据。表中有了数据，我们就可以使用SQL去查询了。要注意一下，流处理中的数据是只有新增的，所以看起来数据会源源不断地添加到表中。</p>
<p>动态表也是一种表，既然是表，就应该能够被查询。我们来回想一下原先我们查询表的场景。</p>
<p>打开编译工具，编写一条SQL语句</p>
<ul>
<li>
<p>将SQL语句放入到mysql的终端执行</p>
</li>
<li>
<p>查看结果</p>
</li>
<li>
<p>再编写一条SQL语句</p>
</li>
<li>
<p>再放入到终端执行</p>
</li>
<li>
<p>再查看结果</p>
</li>
</ul>
<p>……如此反复</p>
<p>而针对动态表，Flink的source端肯定是源源不断地会有数据流入，然后我们基于这个数据流建立了一张表，再编写SQL语句查询数据，进行处理。这个SQL语句一定是不断地执行的，而不是只执行一次。</p>
<p>注意：针对流处理的SQL绝对不会像批式处理一样，执行一次拿到结果就完了。而是会不停地执行，不断地查询获取结果处理。所以，官方给这种查询方式取了一个名字，叫Continuous Query，中文翻译过来叫连续查询。而且每一次查询出来的数据也是不断变化的。</p>
<figure data-type="image" tabindex="3"><img src="https://tianxiawuhao.github.io/post-images/1681541829648.png" alt="" loading="lazy"></figure>
<p>该示意图描述了：我们通过建立动态表和连续查询来实现在无界流中的SQL操作。</p>
<p>大家也可以看到，在Continuous上面有一个State，表示查询出来的结果会存储在State中，再下来Flink最终还是使用流来进行处理。</p>
<p>所以，我们可以理解为Flink的Table API和SQL，是一个逻辑模型，通过该逻辑模型可以让我们的数据处理变得更加简单。</p>
<figure data-type="image" tabindex="4"><img src="https://tianxiawuhao.github.io/post-images/1681541845694.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://tianxiawuhao.github.io/post-images/1681541857678.png" alt="" loading="lazy"></figure>
<h3 id="32-表与stream的转换">3.2 表与Stream的转换</h3>
<h4 id="321-表中的update和delete">3.2.1 表中的Update和Delete</h4>
<p>我们前面提到的表示不断地 Append，表的数据是一直累加的，因为表示对接Source的，Source是不会有update的，但如果我们编写了一个SQL。这个SQL看起来是这样的：</p>
<pre><code class="language-sql">SELECT user, sum(money) FROM order GROUP BY user;
</code></pre>
<p>当执行一条SQL语句之后，这条语句的结果还是一个表，因为在Flink中执行的SQL是Continuous Query，这个表的数据是不断变化的。新创建的表存在Update的情况。仔细看下下面的示例，例如：</p>
<ul>
<li>
<p>第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</p>
</li>
<li>
<p>第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</p>
</li>
<li>
<p>第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</p>
</li>
<li>
<p>….</p>
</li>
</ul>
<p>大家发现了吗，现在数据结果是有Update的，张三一开始是2000，但后面变成了2300。</p>
<p>那还有删除的情况吗？有的，看下面这条SQL语句：</p>
<pre><code class="language-sql">SELECT t1.`user`, SUM(t1.`money`) FROM t_order t1
WHERE
NOT EXISTS (SELECT T2.`user`AS TOTAL_MONEY FROM t_order t2 WHERE T2.`user` = T1.`user` GROUP BY t2.`user` HAVING SUM(T2.`money`) &gt; 3000)
GROUP BY t1.`user`GROUP BY t1.`user`
</code></pre>
<ul>
<li>
<p>第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</p>
</li>
<li>
<p>第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</p>
</li>
<li>
<p>第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</p>
</li>
<li>
<p>第四条数据，张三,800，继续执行这条SQL语句，结果是，李四,1500</p>
</li>
</ul>
<p>因为张三的消费的金额已经超过了3000，所以SQL执行完后，张三是被处理掉了。从数据的角度来看，它不就是被删除了吗？</p>
<p>通过上面的两个示例，可以知道在Flink SQL中，对接Source的表都是Append-only的，不断地增加，执行一些SQL生成的表，这个表可能是要UPDATE的、也可能是要INSERT的。</p>
<h4 id="322-对表的编码操作">3.2.2 对表的编码操作</h4>
<p>我们前面说到过，表是一种逻辑结构，而Flink中的核心还是Stream，所以，Table最终还是会以Stream方式来继续处理，如果是以Stream方式处理，最终Stream中的数据有可能会写入到其他的外部系统中，例如：将Stream中的数据写入到MySQL中。</p>
<blockquote>
<p>我们前面也看到了，表是有可能会UPDATE和DELETE的，那么如果是输出到MySQL中，就要执行UPDATE和DELETE语句了，而DataStream我们在学习Flink的时候就学习过了，DataStream是不能更新、删除事件的。</p>
</blockquote>
<p>如果对表的操作是INSERT，这很好办，直接转换输出就好，因为DataStream数据也是不断递增的。但如果一个TABLE中的数据被UPDATE了、或者被DELETE了，如果用流来表达呢？ 因为流不可变的特征，我们肯定要对这种能够进行UPDATE/DELETE的TABLE做特殊操作。</p>
<p>解决方案：我们可以针对每一种操作，INSERT/UPDATE/DELETE都用一个或多个经过编码的事件来表示。例如：</p>
<ul>
<li>
<p>针对UPDATE，我们用两个操作来表达，[DELETE]数据+ [INSERT]数据。也就是先把之前的数据删除，然后再插入一条新的数据。</p>
</li>
<li>
<p>针对DELETE，我们也可以对流中的数据进行编码，[DELETE]数据。</p>
</li>
</ul>
<p>总体来说，我们通过对流数据进行编码，也可以告诉DataStream的下游，[DELETE]表示发出MySQL的DELETE操作，将数据删除。用[INSERT]表示插入新的数据。</p>
<h4 id="323-将表转换为三种不同编码方式的流">3.2.3 将表转换为三种不同编码方式的流</h4>
<p>Flink中的Table API或者SQL支持三种不同的编码方式，分别是：</p>
<ul>
<li>
<p>Append-only流</p>
</li>
<li>
<p>Retract流</p>
</li>
<li>
<p>Upsert流</p>
</li>
</ul>
<h5 id="3231-append-only流">3.2.3.1 Append-only流</h5>
<p>跟INSERT操作对应。这种编码类型的流针对的是只会不断新增的Dynamic Table，这种方式好处理，不需要进行特殊处理，源源不断地往流中发送事件即可。</p>
<h5 id="3232-retract流">3.2.3.2 Retract流</h5>
<p>这种流就和Append-only不太一样，上面的只能处理INSERT，如果表会发生DELETE或者UPDATE，Append-only编码方式的流就不合适了。</p>
<p>Retract流有几种类型的事件类型：</p>
<ul>
<li>
<p>ADD MESSAGE：这种消息对应的就是INSERT操作。</p>
</li>
<li>
<p>RETRACT MESSAGE：直译过来叫撤回消息，这种消息对应的就是DELETE操作。</p>
</li>
</ul>
<p>我们可以看到通过ADD MESSAGE和RETRACT MESSAGE可以很好的向外部系统表达删除和插入操作，那如何进行UPDATE呢？其实RETRACT MESSAGE + ADD MESSAGE即可（先把之前的数据进行删除，然后插入一条新的）。</p>
<figure data-type="image" tabindex="6"><img src="https://tianxiawuhao.github.io/post-images/1681541881950.png" alt="" loading="lazy"></figure>
<h5 id="3233-upsert流">3.2.3.3 Upsert流</h5>
<p>前面我们看到的RETRACT编码方式的流，实现UPDATE是使用DELETE + INSERT模式的。</p>
<p>大家想一下：在MySQL中我们更新数据的时候，肯定不会先DELETE掉一条数据，然后再插入一条数据，肯定是直接发出UPDATE语句执行更新。</p>
<p>而Upsert编码方式的流，是能够支持Update的，这种效率更高。它同样有两种类型的消息：</p>
<ul>
<li>
<p>UPSERT MESSAGE：这种消息可以表示要对外部系统进行Update或者INSERT操作</p>
</li>
<li>
<p>DELETE MESSAGE：这种消息表示DELETE操作。</p>
</li>
</ul>
<p>Upsert流是要求必须指定Primary Key的，因为Upsert操作是要有Key的，Upsert流针对UPDATE操作用一个UPSERT MESSAGE就可以描述，所以效率会更高。</p>
<figure data-type="image" tabindex="7"><img src="https://tianxiawuhao.github.io/post-images/1681541899440.png" alt="" loading="lazy"></figure>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#table-api-sql-%E4%BB%8B%E7%BB%8D">Table API &amp; SQL 介绍</a>
<ul>
<li><a href="#11-flink-table%E6%A8%A1%E5%9D%97">1.1 Flink Table模块</a></li>
<li><a href="#12-table-api-sql%E7%89%B9%E7%82%B9">1.2 Table API &amp; SQL特点</a></li>
<li><a href="#13-table-api-sql%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B">1.3 Table API&amp; SQL发展历程</a></li>
</ul>
</li>
<li><a href="#03-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87">03 开发准备</a>
<ul>
<li><a href="#21-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">2.1 添加依赖</a></li>
<li><a href="#22-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">2.2 程序结构</a></li>
<li><a href="#23-api">2.3 API</a>
<ul>
<li><a href="#231-%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83">2.3.1 获取环境</a></li>
<li><a href="#233-%E5%88%9B%E5%BB%BA%E8%A1%A8">2.3.3 创建表</a></li>
<li><a href="#234-%E6%9F%A5%E8%AF%A2%E8%A1%A8">2.3.4 查询表</a></li>
<li><a href="#235-%E5%86%99%E5%87%BA%E8%A1%A8">2.3.5 写出表</a></li>
<li><a href="#236-%E4%B8%8Edatastream%E9%9B%86%E6%88%90">2.3.6 与DataStream集成</a>
<ul>
<li><a href="#3361-%E4%BB%8Edatastream%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">3.3.6.1 从DataStream创建视图</a></li>
<li><a href="#2362-%E8%BD%AC%E6%8D%A2datastream%E5%88%B0%E8%A1%A8">2.3.6.2 转换DataStream到表</a></li>
<li><a href="#2363-%E8%BD%AC%E6%8D%A2%E8%A1%A8%E5%88%B0datastream">2.3.6.3 转换表到DataStream</a></li>
</ul>
</li>
<li><a href="#237-tableapi">2.3.7 TableAPI</a></li>
<li><a href="#238-sql">2.3.8 SQL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#03-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">03 相关概念</a>
<ul>
<li><a href="#31-%E5%8A%A8%E6%80%81%E8%A1%A8%E5%92%8C%E8%BF%9E%E7%BB%AD%E6%9F%A5%E8%AF%A2">3.1 动态表和连续查询</a></li>
<li><a href="#32-%E8%A1%A8%E4%B8%8Estream%E7%9A%84%E8%BD%AC%E6%8D%A2">3.2 表与Stream的转换</a>
<ul>
<li><a href="#321-%E8%A1%A8%E4%B8%AD%E7%9A%84update%E5%92%8Cdelete">3.2.1 表中的Update和Delete</a></li>
<li><a href="#322-%E5%AF%B9%E8%A1%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C">3.2.2 对表的编码操作</a></li>
<li><a href="#323-%E5%B0%86%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E7%9A%84%E6%B5%81">3.2.3 将表转换为三种不同编码方式的流</a>
<ul>
<li><a href="#3231-append-only%E6%B5%81">3.2.3.1 Append-only流</a></li>
<li><a href="#3232-retract%E6%B5%81">3.2.3.2 Retract流</a></li>
<li><a href="#3233-upsert%E6%B5%81">3.2.3.3 Upsert流</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/ODDWghbcN/">
                <span class="post-title">
                  第十章 Table API 与 SQL&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/rxadb61B8/">
              <span class="post-title">
                第九章 状态编程和容错机制&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>