<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>七大查询算法 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="七大查询算法 | tianxia » Feed"
  href="https://tianxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tianxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="七大查询算法" />
  <meta property="og:url" content="https://tianxiawuhao.github.io/L2uhkBI__/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tianxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://tianxiawuhao.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1742729663519"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tianxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tianxiawuhao.github.io/nUOlUI5VKeM/" class="tag">算法</a>
                
              </span>
              <h1>七大查询算法</h1>
              <span class="meta">
                Posted on
                2024-02-28，38 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tianxiawuhao.github.io/post-images/L2uhkBI__.png" alt="封面图">
          </img>
          
          <h2 id="前言">前言</h2>
<p>在非数值运算问题中，数据存储量一般很大，为了在大量信息中找到某些值，需要用到查找技术，为了提高查找效率，需要对一些数据进行排序。查找和排序的数据处理量占有非常大的比重，故查找和排序的有效性直接影响到算法的性能，因而查找和排序是重要的处理技术。<br>
  <strong>几个与查找有关的基本概念：</strong><br>
  <strong>查找表</strong>：由同一类型的数据元素构成的集合。由于数据元素之间存在着完全松散的关系，因此查找表是一种非常灵活的结构，可以利用任意数据结构实现。<br>
  <strong>关键字</strong>：数据元素的某个数据项的值，用它可以标识查找表中一个或一组数据元素。如果一个关键字可以唯一标识查找表中的一个数据元素，则称其为 主关键字，否则为次关键字。当数据元素仅有一个数据项时，其关键字即为该数据元素的值。<br>
  <strong>查找</strong>：根据给定的关键字值，在查找表中确定一个关键字与给定值相同的数据元素，并返回该数据元素在查找表中的位置。若找到相应数据元素，则称查找成功，否则称查找失败，此时返回空地址。<br>
  <strong>平均查找长度</strong>：为确定数据元素在查找表中的位置，需要和给定的值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度。</p>
<p>查找两种常见的分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态查找</td>
<td>只做查找操作的查找表，即：   <br />1、查询某个“特定的”数据元素是否在表中   <br />2、检索某个“特定的”数据元素和各种属性</td>
</tr>
<tr>
<td>动态查找</td>
<td>在查找中同时进行插入或删除等操作</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>类别</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序查找</td>
<td>被查找数列有序无序均可</td>
</tr>
<tr>
<td>有序查找</td>
<td>被查找数列为有序数列</td>
</tr>
</tbody>
</table>
<p><strong>查找算法有七种，分别为：顺序查找、二分查找、插值查找、斐波那契查找、树表查找、分块查找、哈希查找。</strong><br>
基于线性结构的查找，有两种最常见的查找方法：顺序查找和折半查找。</p>
<p><strong>顺序查找</strong><br>
  顺序查找的特点是，用所给的关键字与线性表中各元素的关键字逐个进行比较，直到成功或失败。<br>
<strong>折半查找</strong><br>
  折半查找又称为二分查找，这种查找方法需要待查的查找表满足两个条件：首先，查找表必须使用顺序的存储结构；其次，查找表必须按关键字大小有序排列。算法的基本思想是：首先，将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；否则利用中间元素将表一分为二，如果中间元素关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。重复以上过程，直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。</p>
<h2 id="一-顺序查找">一、顺序查找</h2>
<h3 id="11-顺序查找介绍">1.1 顺序查找介绍</h3>
<p>顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。</p>
<p><strong>基本思路</strong><br>
  从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。<br>
<strong>复杂度分析</strong><br>
  查找成功时的平均查找长度为： ASL = 每个元素被查找的概率 * 总的元素的个数=1/n*(1+2+3+…+n) = (n+1)/2 ;<br>
  当查找不成功时，需要n+1次比较，时间复杂度为O(n)，所以，顺序查找的时间复杂度为O(n)。<br>
<strong>优缺点</strong><br>
  缺点：是当n 很大时，平均查找长度较大，效率低；<br>
  优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</p>
<h3 id="12-顺序查找实现">1.2 顺序查找实现</h3>
<p>用Java代码实现顺序查找，示例代码如下：</p>
<pre><code class="language-java"> private static int sequenceSearch(int[] array,int target){
	 for(int i=0;i&lt;array.length;i++){
		 if(target==array[i])
			 return i;
	 }
	 return -1;
 }
</code></pre>
<h3 id="13-顺序查找优化">1.3 顺序查找优化</h3>
<p>在算法中，比较和赋值是比较耗时的。在上面的顺序查找实现代码中，存在着数组下标和目标值两种比较，那么能不能转变为一种比较呢？答案是可以的，不过要进行数据预处理，将查找值也放到数列中。比如将要查找的元素放在原数列中的第一位或最后一位(如果需要扩容就进行扩容)。此处将要查找的目标元素放在第一位，预处理示例代码如下：</p>
<pre><code class="language-java">int[] array = {12,3,43,5,9};
int target = 43;
int[] newArray = new int[array.length+1];
newArray[0] = target;
for(int i=0;i&lt;array.length;i++){
    newArray[i+1] = array[i];
}
</code></pre>
<p>也许有人会问，这样预处理一遍数据，需要将数组中所有数组都移动一遍，岂不是更花费时间？从总体上来看，确实是这样的。但是，面临大量的数据要处理时，常常要进行预处理、清洗等操作，这样会令纯粹处理数据（在该例子中就是搜索固定元素）的时间变的更少，更有效。当数据进行预处理后，搜索时就可以不用再比较两次，示例代码如下：</p>
<pre><code class="language-java">public static int sequenceSearchPlus(int[] arr,int key){
	int n=arr.length-1;
	arr[0]=key;
	while(arr[n]!=key){
		n--;
	}
	return n;
}
</code></pre>
<p>完整的测试代码如下：</p>
<pre><code class="language-java">public class BasicTest {
	public static void main(String[] args){
		int[] array = {12,3,43,5,9};
		int target = 43;
		int[] newArray = new int[array.length+1];
		newArray[0] = target;
		for(int i=0;i&lt;array.length;i++){
			newArray[i+1] = array[i];
		}
		int result = sequenceSearchPlus(newArray,target)-1;
		if(result != -1){
			System.out.println(&quot;要查找的元素,在数组中的下标是：&quot;+result);
		}else{
			System.out.println(&quot;要查找的元素不在数组中&quot;);
		}
}	

public static int sequenceSearchPlus(int[] arr,int key){
	int n=arr.length-1;
	arr[0]=key;
	while(arr[n]!=key){
		n--;
	}
	return n;
}
</code></pre>
<p>测试结果为：</p>
<blockquote>
<p>要查找的元素,在数组中的下标是：2</p>
</blockquote>
<h2 id="二-二分查找">二、二分查找</h2>
<h3 id="21-二分查找介绍">2.1 二分查找介绍</h3>
<p>二分查找，是一种在有序数组中查找某一特定元素的查找算法。</p>
<p><strong>基本思路</strong><br>
  用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。<br>
**复杂度分析　**<br>
  假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。被查找区间的大小变化为：n, n/2, n/4, n/8, …, n/(2k)。<br>
  可以看出来，这是一个等比数列。其中 n/(2^k)=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过n/(2^k)=1 ，我们可以求得 k=log2n ，所以时间复杂度就是 O(logn)。空间复杂度：O(1)。<br>
<strong>优缺点分析</strong><br>
  当查找表不会频繁有更新、删除操作时，使用折半查找是比较理想的。如果查找表有较频繁的更新、删除操作，维护表的有序会花费比较大的精力，不建议使用该查找方式。</p>
<h3 id="22-二分查找实现">2.2 二分查找实现</h3>
<p>用Java代码实现折半查找，有两种方式：迭代法和递归法。迭代法示例代码如下：</p>
<pre><code class="language-java">static  int binarySearch1(int arr[],int len,int target){
	/*初始化左右搜索边界*/
    int left=0,right=len-1;
    int mid;
    while(left&lt;=right){
    	/*中间位置：两边界元素之和/2向下取整*/
        mid=(left+right)/2;
        /*arr[mid]大于target，即要寻找的元素在左半边，所以需要设定右边界为mid-1，搜索左半边*/
        if(target&lt;arr[mid]){
            right=mid-1;
        /*arr[mid]小于target，即要寻找的元素在右半边，所以需要设定左边界为mid+1，搜索右半边*/
        }else if(target&gt;arr[mid]){
            left=mid+1;
        /*搜索到对应元素*/
        }else if(target==arr[mid]){
            return mid;
        }
    }
    /*搜索不到返回-1*/
    return -1;
}
</code></pre>
<p><strong>递归法</strong>示例代码如下：</p>
<pre><code class="language-java">static int binarySearch2(int array[],int left,int right,int target){
	if(left&lt;=right){
		int mid=(left+right)/2;
		/*搜索到对应元素*/
		if(array[mid]==target){
			return mid;
		}else if(array[mid]&lt;target){
			/*array[mid]小于target，即要寻找的元素在右半边，所以需要设定左边界为mid+1，搜索右半边*/
			return binarySearch2(array,mid+1,right,target);
		}else{
			/*array[mid]大于target，即要寻找的元素在左半边，所以需要设定右边界为mid-1，搜索左半边*/
			return binarySearch2(array,left,mid-1,target);
		}
	}else{
		return -1;
	}
}
</code></pre>
<h3 id="23-二分查找变体">2.3 二分查找变体</h3>
<p>二分查找算法四种常见的变形问题，分别是：</p>
<ul>
<li>
<p>查找第一个值等于给定值的元素。</p>
</li>
<li>
<p>查找最后一个值等于给定值的元素。</p>
</li>
<li>
<p>查找第一个大于等于给定值的元素。</p>
</li>
<li>
<p>查找最后一个小于等于给定值的元素。</p>
</li>
</ul>
<p><strong>1、查找第一个值等于给定值的元素</strong></p>
<pre><code class="language-java">public static int search(int[] nums, int val) {
    int n = nums.length;
    int low = 0, high = n - 1;
    while (low &lt;= high) {
        int mid = (low + high) &gt;&gt;&gt; 1;
        if (nums[mid] &lt; val) {
           low = mid + 1;
        } else if (nums[mid] &gt; val) {
           high = mid - 1;
        } else {
           // 如果nums[mid]是第一个元素，或者nums[mid-1]不等于val
           // 说明nums[mid]就是第一个值为给定值的元素
          if (mid == 0 || nums[mid - 1] != val) {
              return mid;
          }
          high = mid - 1;
       } 
    }
    return -1;
}
</code></pre>
<p><strong>2、查找最后一个值等于给定值的元素</strong></p>
<pre><code class="language-java">public static int search(int[] nums, int val) {
    int n = nums.length;
    int low = 0, high = n - 1;
    while (low &lt;= high) {
        int mid = (low + high) &gt;&gt;&gt; 1;
        if (nums[mid] &lt; val) {
            low = mid + 1;
        } else if (nums[mid] &gt; val) {
            high = mid - 1;
        } else {
           // 如果nums[mid]是最后一个元素，或者nums[mid+1]不等于val
           // 说明nums[mid]就是最后一个值为给定值的元素
           if (mid == n - 1 || nums[mid + 1] != val) {
              return mid;
           }
           low = mid + 1;
       }
   }
   return -1;
}
</code></pre>
<p><strong>3、查找第一个大于等于给定值的元素</strong></p>
<pre><code class="language-java">public static int search(int[] nums, int val) {
    int low = 0, high = nums.length - 1;
    while (low &lt;= high) {
        int mid = (low + high) &gt;&gt;&gt; 1;
        if (nums[mid] &lt; val) {
            low = mid + 1;
        } else {
            // 如果nums[mid]是第一个元素，或者nums[mid-1]小于val
            // 说明nums[mid]就是第一个大于等于给定值的元素
           if (mid == 0 || nums[mid - 1] &lt; val) {
              return mid;
           }
           high = mid - 1;
       }
    }
    return -1;
}
</code></pre>
<p><strong>4、查找最后一个小于等于给定值的元素</strong></p>
<pre><code class="language-java">public static int search(int[] nums, int val) {
    int n = nums.length;
    int low = 0, high = n - 1;
    while (low &lt;= high) {
        int mid = (low + high) &gt;&gt;&gt; 1;
        if (nums[mid] &gt; val) {
            high = mid - 1;
        } else {
            // 如果nums[mid]是最后一个元素，或者nums[mid+1]大于val
            // 说明nums[mid]就是最后一个小于等于给定值的元素
           if (mid == n - 1 || nums[mid + 1] &gt; val) {
              return mid;
           }
           low = mid + 1;
       }
    }
    return -1;
}
</code></pre>
<h2 id="三-插值查找">三、插值查找</h2>
<h3 id="31-插值查找介绍">3.1 插值查找介绍</h3>
<p>在二分查找中，每次都是从待查找序列的中间点开始查找，这样的做法在正确性上固然没什么问题，但假如要查找的值距离某个边界比较近，还从中间点开始查找，就有点浪费时间了。举个例子来说说明，假如在在一个{1,2…,100}的数组中，要查找88这个值，还一直采用和中间点比较的策略，就显得不太明智，因为明显可以明显从较为靠后的位置去检索。为了克服这种弊端， 引入了插值查找。</p>
<p><strong>基本思路</strong><br>
  插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-array[low])/(array[high]-array[low])*(high-low)。简而言之，基于二分查找算法，将查找点的选择改进为自适应选择。<br>
<strong>复杂度分析</strong><br>
  时间复杂性：如果元素均匀分布，则O(log(logn))，在最坏的情况下可能需要O(n)。<br>
  空间复杂度：O(1)。<br>
<strong>优缺点分析</strong><br>
  对于长度比较长、关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<h3 id="32-插值查找实现">3.2 插值查找实现</h3>
<p>上面的说法是总体介绍，落实到具体代码上的话，再慢慢分析。在二分查找中，mid的计算方式如下：</p>
<p>​	    <img src="https://tianxiawuhao.github.io/post-images/1709120117621.png" alt="" loading="lazy"></p>
<p>将low从分数中提取出来，mid的计算就变成了：</p>
<p>​	  	<img src="https://tianxiawuhao.github.io/post-images/1709120146482.png" alt="" loading="lazy"><br>
  在插值查找中，mid的计算方式转换成了：</p>
<p>​		<img src="https://tianxiawuhao.github.io/post-images/1709120174223.png" alt="" loading="lazy"></p>
<p>有了上面的算术，就可以写代码了，迭代法插值查找示例代码如下：</p>
<pre><code class="language-java">private static int insertSearch1(int arr[],int target){
	/*初始化左右搜索边界*/
    int left=0,right=arr.length-1;
    int mid;
    while(left&lt;=right){
        mid=left+(target-arr[left])/(arr[right]-arr[left])*(right-left);
        /*arr[mid]大于target，即要寻找的元素在左半边，所以需要设定右边界为mid-1，搜索左半边*/
        if(target&lt;arr[mid]){
            right=mid-1;
        /*arr[mid]小于target，即要寻找的元素在右半边，所以需要设定左边界为mid+1，搜索右半边*/
        }else if(target&gt;arr[mid]){
            left=mid+1;
        /*搜索到对应元素*/
        }else if(target==arr[mid]){
            return mid;
        }
    }
    /*搜索不到返回-1*/
    return -1;
}
</code></pre>
<p><strong>递归法</strong>插值查找示例代码如下：</p>
<pre><code class="language-java">private static int insertSearch2(int array[],int left,int right,int target){
	if(left&lt;=right){
		int mid=left+(target-array[left])/(array[right]-array[left])*(right-left);
		/*搜索到对应元素*/
		if(array[mid]==target){
			return mid;
		}else if(array[mid]&lt;target){
			/*array[mid]小于target，即要寻找的元素在右半边，所以需要设定左边界为mid+1，搜索右半边*/
			return insertSearch2(array,mid+1,right,target);
		}else{
			/*array[mid]大于target，即要寻找的元素在左半边，所以需要设定右边界为mid-1，搜索左半边*/
			return insertSearch2(array,left,mid-1,target);
		}
	}else{
		return -1;
	}
}
</code></pre>
<h2 id="四-斐波那契查找">四、斐波那契查找</h2>
<h3 id="41-斐波那契查找介绍">4.1 斐波那契查找介绍</h3>
<p>和前面的二分查找、插值查找相比，斐波那契查找是类似的，不过换了一种寻找mid点的方法。顾名思义，该种查找方法中，使用到了斐波那契数列，斐波那契数列的形式是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。</p>
<p><strong>基本思路</strong><br>
  在斐波那契数列中的元素满足这样的关系：F[k]=F[k-1]+F[k-2]，此处将这个数组稍微改一下，改成：（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1，图示如下：<br>
  <img src="https://tianxiawuhao.github.io/post-images/1709120204362.png" alt="" loading="lazy"><br>
  通过上面的图，应该就可以看出为什么要这样分割数组了，因为要找出一个中间mid值，以便将数组按斐波那契数列的规律，分割成两部分。<br>
<strong>复杂度分析</strong><br>
  最坏情况下，时间复杂度为O(logn)，且其期望复杂度也为O(logn)。</p>
<h3 id="42-斐波那契查找实现">4.2 斐波那契查找实现</h3>
<p>上面介绍了分割的方法，但还有一个问题，就是斐波那契数列中的数值都是固定的，但要查找的数组的长度不固定，这样情况要怎么办？此时需要的是创建新数组，使新数组的长度是斐波那契数列中的值，并且是比原数组长度略大的值（此处只能是略大，因为略小的话，就会导致原数组元素丢失)，多出来的元素用原数组最高位元素补充，示例代码如下：</p>
<pre><code class="language-java">int high = arr.length - 1;
int f[] = fib();
/*获取最相邻的斐波那契数组中元素的值，该值略大于数组的长度*/
while(high &gt; f[k] - 1) {
    k++;
}
/*因为 f[k]值可能大于arr的长度。如果大于时，需要构造一个新的数组temp[]，将arr数组中的元素拷贝过去，不足的部分会使用0填充*/
int[] temp=Arrays.copyOf(arr, f[k]);
/*然后将temp后面填充的0，替换为最后一位数字
	 *如将temp数组由{1,8,10,89,100,134,0,0}变换为{1,8,10,89,100,134,134,134}*/
for(int i = high + 1; i &lt; temp.length; i++) {
    temp[i] = arr[high];
}
</code></pre>
<p>解决了如何分割、如果创建临时新数组后，还有一个问题：怎么判断最后target == arr[i]时，这个arr[i]是原来的数组中的元素，还是在新数组中扩展出来的元素？如果是新数组中扩展出来的元素，该元素的下标是大于原数组元素的最大下标的，肯定不是要寻找的位置。其实该问题容易解决，就是当target == arr[i]时，如果arr[i]的下标&gt;原数组最大下标时，直接返回元数组最大下标即可。示例代码如下：</p>
<pre><code class="language-java">/*原arr数组中的值*/
if(mid &lt;= high){
    return mid;
    /*在temp中，扩展出来的高位的值*/
}else{
    return high;
}
</code></pre>
<p>完整斐波那契查找示例代码如下：</p>
<pre><code class="language-java">public class FibonacciSearch {
    public static int FLENGTH = 20;
    public static void main(String[] args) {
        int [] arr = {1,8,10,89,100,134};
        int target = 89;
        System.out.println(&quot;目标元素在数组中位置是：&quot; + fibSearch(arr, target));		
    }

    public static int[] fib() {
        int[] f = new int[FLENGTH];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i &lt; FLENGTH; i++) {
            f[i] = f[i-1] + f[i-2];
        }
        return f;
    }

    public static int fibSearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        int k = 0; 
        int mid = 0; 
        int f[] = fib();
        /*获取最相邻的斐波那契数组中元素的值，该值略大于数组的长度*/
        while(high &gt; f[k] - 1) {
            k++;
        }
        /*因为 f[k]值可能大于arr的长度。如果大于时，需要构造一个新的数组temp[]，将arr数组中的元素拷贝过去，不足的部分会使用0填充*/
        int[] temp=Arrays.copyOf(arr, f[k]);
        /*然后将temp后面填充的0，替换为最后一位数字
	 *如将temp数组由{1,8,10,89,100,134,0,0}变换为{1,8,10,89,100,134,134,134}*/
        for(int i = high + 1; i &lt; temp.length; i++) {
            temp[i] = arr[high];
        }

        while (low &lt;= high) { 
            mid = low + f[k - 1] - 1;
            if(target &lt; temp[mid]) { 
                high = mid - 1;
                /*因为f[k]=f[k-1]+f[k-2]，所以k--就相当于取temp数组的左边部分*/
                k--;
            } else if ( target &gt; temp[mid]) { 
                low = mid + 1;
                /*同理，f[k]=f[k-1]+f[k-2]，k -= 2就相当于取temp数组的右边部分*/
                k -= 2;
            } else {
                /*原arr数组中的值*/
                if(mid &lt;= high){
                    return mid;
                    /*在temp中，扩展出来的高位的值*/
                }else{
                    return high;
                }
            }
        }
        return -1;
    }
}
</code></pre>
<h2 id="五-树表查找">五、树表查找</h2>
<p>基于树的查找方法是将待查表组织成特定的树结构，并在树结构的基础上实现查找的方法。</p>
<h3 id="51-二叉树查找">5.1 二叉树查找</h3>
<p>二叉排序树（二叉查找树）是最简单的树表查找算法，该算法需要利用待查找的数据，进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，然后再进行查找。</p>
<p><strong>二叉排序树的性质</strong><br>
  二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>
   - 1&gt;若左子树不空，则左子树上所有结点的键值均小于或等于它的根结点的键值。<br>
   - 2&gt;若右子树不空，则右子树上所有结点的键值均大于或等于它的根结点的键值。<br>
   - 3&gt;左、右子树也分别为二叉排序树。</p>
<h4 id="511-二叉排序树中序遍历">5.1.1 二叉排序树中序遍历</h4>
<p>二叉排序树有不同的遍历方式，中序遍历的结果比较直观。二叉树示例：<br>
  <img src="https://tianxiawuhao.github.io/post-images/1709120223667.png" alt="" loading="lazy"><br>
  二叉树上中序遍历的方式是：左节点、根节点、右节点。该二叉树的遍历结果为：1、3、4、6、7、8、10、13、14。</p>
<h4 id="512-二叉树查找实现">5.1.2 二叉树查找实现</h4>
<p><strong>1、创建二叉树</strong><br>
首先，要创建一个树的节点，节点中要有该节点储存的值，然后起左右子树。示例代码：</p>
<pre><code class="language-java">class BinaryTree{
    int value;
    BinaryTree left;
    BinaryTree right;
    public BinaryTree(int value){
        this.value = value;
    }
}
</code></pre>
<p>接下来就要创建二叉排序树，创建二叉排序树是一个递归的过程，需要将序列中的值一个一个添加到二叉树中。方便起见，可以利用序列中第一个元素作为根节点，再持续添加节点，示例代码：</p>
<pre><code class="language-java">int[] array = {35,76,6,22,16,49,49,98,46,9,40};
BinaryTree root = new BinaryTree(array[0]);
for(int i = 1; i &lt; array.length; i++){
    createBST(root, array[i]);
}
</code></pre>
<p>具体创建树的过程，就是一个不断与根节点比较，然后添加到左侧、右侧或不添加的过程。因为在二叉排序树中，不存在重复元素，有相等元素已经在树中时，直接忽略后续相等元素。示例代码：</p>
<pre><code class="language-java">public static void createBST(BinaryTree root, int element){
    BinaryTree newNode = new BinaryTree(element);
    if(element &gt; root.value){
        if(root.right == null)
            root.right = newNode;
        else
            createBST(root.right, element);
    }else if(element &lt; root.value){
        if(root.left == null)
            root.left = newNode;
        else
            createBST(root.left, element);
    }else{
        System.out.println(&quot;该节点&quot; + element + &quot;已存在&quot;);
        return;
    }
}
</code></pre>
<p><strong>2、二叉树查找</strong><br>
  查找元素是否在树中的过程，就是一个二分查找的过程，不过查找的对象从左右子序列转换成了左右子树而已。示例代码：</p>
<pre><code class="language-java">public static void searchBST(BinaryTree root, int target, BinaryTree p){
    if(root == null){
        System.out.println(&quot;查找&quot;+target+&quot;失败&quot;);
    }else if(root.value == target){
        System.out.println(&quot;查找&quot;+target+&quot;成功&quot;);
    }else if(root.value &gt;= target){
        searchBST(root.left, target, root);
    }else{ 
        searchBST(root.right, target, root);
    }
}
</code></pre>
<p>完整示例代码：</p>
<p>​</p>
<pre><code class="language-java">public class BinarySortTree {
    public static void main(String[] args) {
        int[] array = {35,76,6,22,16,49,49,98,46,9,40};
        BinaryTree root = new BinaryTree(array[0]);
        for(int i = 1; i &lt; array.length; i++){
            createBST(root, array[i]);
        }
        System.out.println(&quot;中序遍历结果：&quot;);
        midOrderPrint(root);
        System.out.println();
        searchBST(root, 22, null);
        searchBST(root, 100, null);
    }

    /*创建二叉排序树*/
    public static void createBST(BinaryTree root, int element){
        BinaryTree newNode = new BinaryTree(element);
        if(element &gt; root.value){
            if(root.right == null)
                root.right = newNode;
            else
                createBST(root.right, element);
        }else if(element &lt; root.value){
            if(root.left == null)
                root.left = newNode;
            else
                createBST(root.left, element);
        }else{
            System.out.println(&quot;该节点&quot; + element + &quot;已存在&quot;);
            return;
        }
    }

    /*二叉树中查找元素*/
    public static void searchBST(BinaryTree root, int target, BinaryTree p){
        if(root == null){
            System.out.println(&quot;查找&quot;+target+&quot;失败&quot;);
        }else if(root.value == target){
            System.out.println(&quot;查找&quot;+target+&quot;成功&quot;);
        }else if(root.value &gt;= target){
            searchBST(root.left, target, root);
        }else{ 
            searchBST(root.right, target, root);
        }
    }

    /*二叉树的中序遍历*/
    public static void midOrderPrint(BinaryTree rt){
        if(rt != null){
            midOrderPrint(rt.left);
            System.out.print(rt.value + &quot; &quot;);
            midOrderPrint(rt.right);	
        }
    }
}
</code></pre>
<p><strong>测试结果为：</strong></p>
<blockquote>
<p>该节点49已存在<br>
中序遍历结果：<br>
6 9 16 22 35 40 46 49 76 98<br>
查找22成功<br>
查找100失败</p>
</blockquote>
<h2 id="六-分块查找">六、分块查找</h2>
<h3 id="61-分块查找介绍">6.1 分块查找介绍</h3>
<p>分块查找，顾名思义，要先将所有元素按大小进行分块，然后在块内进行查找。在分块时，块内的元素不一定是有序的，只要一个块内的元素在同一区间就行。用较标准的语言描述是：算法的思想是将n个数据元素&quot;按块有序&quot;划分为m块（m≤n）。每一块中的结点不必有序，但块与块之间必须&quot;按块有序&quot;，每个块内的的最大元素小于下一块所有元素的任意一个值。<br>
  所以，在使用分块查找时，分成了两步：</p>
<p>- 1&gt;找到元素可能在的块。<br>
   - 2&gt;在对应的块内查找元素。</p>
<h3 id="62-分块查找实现">6.2 分块查找实现</h3>
<p>在上个章节说到，该方法要先分块，那么块应该具有怎样的属性呢？至少要有以下元素：<br>
   - 1&gt;长度<br>
    一般是固定的长度。<br>
   - 2&gt;起始位置<br>
    当块的长度固定后，需要确定起始位置才能固定不同的块表示的元素的位置范围。<br>
   - 3&gt;块标识<br>
    该标识用来标识块内元素的范围，可以用最大值、最小值、平均值等多种方式来表示。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">public class Block {
	/*block的索引，用来标识块中元素*/
    public int index;
    /*该block的开始位置*/
    public int start; 
    /*块元素长度，在该例子中0代表空元素，不计入block长度*/
    public int length;
	

    public Block(int index, int start, int length) {
        this.index = index;
        this.start = start;
        this.length = length;
    }

}
</code></pre>
<p>在该例子中，定义元素数组和块数组，示例如下：</p>
<pre><code class="language-java">/*主表*/
static int[] valueList = new int[]{
	104, 101, 103, 105,102, 0, 0, 0, 0, 0,
    201, 202, 204, 203,0,   0, 0, 0, 0, 0,
    303, 301, 302,  0,   0,   0, 0, 0, 0, 0
};

/*索引表*/
static Block[] indexList = new Block[]{
	new Block(1, 0, 5),
	new Block(2, 10, 4),
	new Block(3, 20, 3)
};
</code></pre>
<p>valueList中的0，可以简单理解为块内的空元素；indexList中的1,2,3代表块内元素的取值范围，第一个块内是100-200之间的元素，第2个块内是200-300之间的元素，以此类推。<br>
  在进行元素查找时，先判断是否存在元素可能存在的块。示例如下：</p>
<pre><code class="language-java">/*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/
int index = key/100;
/*找到对应的block*/
for(int i = 0;i &lt; indexList.length; i++) {
    if(indexList[i].index == index) {
        indexItem = indexList[i];
        break;
    }
}

/*如果数组中不存在对应的块，则返回-1，查找失败*/
if(indexItem == null)
    return -1;
</code></pre>
<p>找到内对的块后，就在该块内进行搜索，示例代码如下：</p>
<pre><code class="language-java">/*在对应的block中查找*/
for(int i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) {
    if(valueList[i] == key)
        return i;
}
return -1;
</code></pre>
<p>如果需要在数组中插入元素，同样需要需要先查找是否存在对应的块，如果存在，则追加到该块中元素的尾部。<br>
<strong>完整示例代码如下：</strong></p>
<pre><code class="language-java">public class BlockSearch {
	/*主表*/
    static int[] valueList = new int[]{
    	104, 101, 103, 105,102, 0, 0, 0, 0, 0,
        201, 202, 204, 203,0,   0, 0, 0, 0, 0,
        303, 301, 302,  0,   0,   0, 0, 0, 0, 0
    };

    /*索引表*/
    static Block[] indexList = new Block[]{
    	new Block(1, 0, 5),
    	new Block(2, 10, 4),
    	new Block(3, 20, 3)
    };
    
    public static void main(String[] args) {
    	System.out.println(&quot;原始主表：&quot;);
    	printElemts(valueList);
    	
    	/*分块查找*/
    	int searchValue = 203;
    	System.out.println(&quot;元素&quot;+searchValue+&quot;，在列表中的索引为：&quot;+blockSearch(searchValue)+&quot;\n&quot;);
    	
        /*插入数据并查找*/
    	int insertValue = 106;
    	         
    	/*插入成功，查找插入位置*/
        if (insertBlock(insertValue)) {
    	   System.out.println(&quot;插入元素&quot;+insertValue+&quot;后的主表：&quot;);
    	   printElemts(valueList);
    	   System.out.println(&quot;元素&quot; + insertValue + &quot;在列表中的索引为：&quot; + blockSearch(insertValue));
        }
    }
    
    public static void printElemts(int[] array) {
        for(int i = 0; i &lt; array.length; i++){
            System.out.print(array[i]+&quot; &quot;);
            if ((i+1)%10 == 0) {
                System.out.println();
            }
        }
    }


​	 

	/*插入数据*/
	public static boolean insertBlock(int key) {
	    Block item = null;
	
	    /*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/
	    int index = key/100;
	    int i = 0;
	    /*找到对应的block*/
	    for (i = 0; i &lt; indexList.length; i++) {
	        if (indexList[i].index == index) {
	            item = indexList[i];
	            break;
	        }
	    }
	    /*如果数组中不存在对应的块，则不能插入该数据*/
	    if (item == null) {
	       return false;
	    }
	
	    /*将元素插入到每个块的最后*/
	    valueList[item.start + item.length] = key;
	    /*更新该块的长度*/
	    indexList[i].length++;
	    return true;
	} 
	 
	public static int blockSearch(int key) {
	    Block indexItem = null;
	
	    /*确定插入到哪个块中，在该例子中，第一个block中放的是100-200之间的数，第二个block中放的是200-300之间的数，以此类推*/
	    int index = key/100;
	    /*找到对应的block*/
	    for(int i = 0;i &lt; indexList.length; i++) {
	       if(indexList[i].index == index) {
	           indexItem = indexList[i];
	           break;
	       }
	   }
	
	    /*如果数组中不存在对应的块，则返回-1，查找失败*/
	   if(indexItem == null)
	       return -1;
	
	   /*在对应的block中查找*/
	   for(int i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) {
	       if(valueList[i] == key)
	           return i;
	    }
	   	return -1;
	}

}
</code></pre>
<p><strong>测试结果如下：</strong></p>
<blockquote>
<p>原始主表：<br>
104 101 103 105 102 0 0 0 0 0<br>
201 202 204 203 0 0 0 0 0 0<br>
303 301 302 0 0 0 0 0 0 0<br>
元素203，在列表中的索引为：13<br>
插入元素106后的主表：<br>
104 101 103 105 102 106 0 0 0 0<br>
201 202 204 203 0 0 0 0 0 0<br>
303 301 302 0 0 0 0 0 0 0<br>
元素106在列表中的索引为：5</p>
</blockquote>
<h2 id="七-哈希查找">七、哈希查找</h2>
<h3 id="71-哈希查找介绍">7.1 哈希查找介绍</h3>
<p>要了解哈希查找，就要先了解一下哈希表和哈希函数。先看下标准的定义：哈希表，是根据关键值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）。<br>
  从上面的定义可以看出：哈希查找与线性表查找和树表查找最大的区别在于，不用数值比较。</p>
<h4 id="711-构造哈希表">7.1.1 构造哈希表</h4>
<p>要使用哈希查找，就要先有哈希表，所以需要先介绍一下哈希表的构造方法。常见的构造方法有如下几种：</p>
<ul>
<li>
<p>1、直接定址法<br>
  哈希地址：f(key) = a*key+b (a、b为常数)。<br>
  这种方法的优点是：简单、均匀、不会产生冲突。但是需要事先知道 key 的分布情况，适合查找表较小并且连续的情况。</p>
</li>
<li>
<p>2、数字分析法<br>
  假设关键字是R进制数（如十进制）。并且哈希表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成哈希地址。选取的原则是使得到的哈希地址尽量避免冲突，即所选数位上的数字尽可能是随机的。<br>
  举个例子：比如11位手机号码“136xxxx5889”，其中前三位是接入号，一般对应不同运营公司的子品牌，中间四位表示归属地，最后四位才是用户号，此时就可以用后4位来作为哈希地址。</p>
</li>
<li>
<p>3、平方取中法<br>
  取key平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，仅取其中的几位为地址不一定合适。而一个数平方后的中间几位数和数的每一位都相关， 由此得到的哈希地址随机性更大。如key是1234，那么它的平方就是1522756，再抽取中间的3位就是227作为 f(key) 。</p>
</li>
<li>
<p>4、折叠法<br>
  折叠法是将 key 从左到右分割成位数相等的几个部分(最后一部分位数不够可以短些)，然后将这几部分叠加求和，并按哈希表的表长，取后几位作为 f(key) 。<br>
  比如key是9876543210，哈希表的表长为3位，我们将 key 分为4组，987 | 654 | 321 | 0 ，然后将它们叠加求和 987+654+321+0=1962，再取后3位即得到哈希位置是：962 。</p>
</li>
<li>
<p>5、除留余数法<br>
  取关键字被某个不大于哈希表表长 m 的数 p 除后所得的余数为哈希地址。即 f(key) = key % p (p ≤ m)。这种方法是最常用的哈希函数构造方法。</p>
</li>
<li>
<p>6、随机数法<br>
  哈希地址：random(key) ，这里random是随机函数，当 key 的长度不等时，采用这种方法比较合适。</p>
</li>
</ul>
<h4 id="712-解决冲突">7.1.2 解决冲突</h4>
<p>在使用以上方法计算key对应的哈希地址时，难免会遇到两个key不相等，到计算出来的哈希地址相同的情况，该情况就被称为“冲突”。在构造哈希表，常用如下方式解决冲突：</p>
<ul>
<li>
<p>1、开放定址法<br>
  该方法指的是两个key在计算出相同的哈希地址时，后者继续在哈希表中向后寻找空位置，存放改key的方法。举个例子：假如原始的key中有8、15两个元素，哈希表中的长度为7，当使用key % length求余时，两个key会计算出相同的哈希位置。假设哈希表中的1位置已经存放了8，那么15就要从1位置往后寻找空位，假如2位置是空的，就可以把15存放到2位置；假如2位置不空，就要往3位置寻找，以此类推。</p>
</li>
<li>
<p>2、拉链法<br>
  该方法中处理相同位置的方式是：创建一个List，存储相同位置上不同值的key，此处借用网上的一张图来表示：<br>
  <br>
  <img src="https://tianxiawuhao.github.io/post-images/1709120257362.png" alt="" loading="lazy"></p>
</li>
</ul>
<h3 id="72-哈希查找实现">7.2 哈希查找实现</h3>
<p>依据上文介绍，先构建哈希表。而要构建哈希表，就要先有计算地址的方法，示例代码如下：</p>
<pre><code class="language-java">/*用除留余数法计算要插入元素的地址*/
public static int hash(int[] hashTable, int data) {
    return data % hashTable.length;
}
</code></pre>
<p>有了计算哈希地址的方法后，剩下的就是将原始的元素插入到哈希表中，也就是先利用key计算一个地址，如果这个地址以及有元素了，就继续向后寻找。此处可以循环计算地址，示例代码如下：</p>
<pre><code class="language-java">/*将元素插入到哈希表中*/
public static void insertHashTable(int[] hashTable, int target) {
    int hashAddress = hash(hashTable, target);

    /*如果不为0，则说明发生冲突*/
    while (hashTable[hashAddress] != 0) {
        /*利用开放定址法解决冲突，即向后寻找新地址*/
        hashAddress = (++hashAddress) % hashTable.length;
    }

    /*将元素插入到哈希表中*/
    hashTable[hashAddress] = target;
}
</code></pre>
<p>哈希表构建后，就是在哈希表中查找元素了。在查找元素时，容易想到的情况是：在直接计算出的哈希地址及其后续位置查找元素。特殊的是，上一步中，有循环计算地址的操作，所以此处计算到原始地址时，也代表查找失败。示例代码如下：</p>
<pre><code class="language-java">public static int searchHashTable(int[] hashTable, int target) {
    int hashAddress = hash(hashTable, target);

    while (hashTable[hashAddress] != target) {
        /*寻找原始地址后面的位置*/
        hashAddress = (++hashAddress) % hashTable.length;
        /*查找到开放单元(未存放元素的位置)或 循环回到原点，表示查找失败*/
        if (hashTable[hashAddress] == 0 || hashAddress == hash(hashTable, target)) {
            return -1;
        }
    }
    return hashAddress;
}
</code></pre>
<p><strong>完整示例代码如下：</strong></p>
<pre><code class="language-java">public class HashSearch {

    /*待查找序列*/
    static int[] array = {13, 29, 27, 28, 26, 30, 38};
    /* 初始化哈希表长度，此处哈希表容量设置的和array长度一样。
     * 其实正常情况下，哈希表长度应该要长于array长度，因为使用
     * 开放地址法时，可能会多使用一些空位置
     */
    static int hashLength = 7;
    static int[] hashTable = new int[hashLength];
    
    public static void main(String[] args) {
        /*将元素插入到哈希表中*/
        for (int i = 0; i &lt; array.length; i++) {
        	insertHashTable(hashTable, array[i]);
        }
        System.out.println(&quot;哈希表中的数据：&quot;);
        printHashTable(hashTable);
        
        int data = 28;
        System.out.println(&quot;\n要查找的数据&quot;+data);
        int result = searchHashTable(hashTable, data);
        if (result == -1) {
            System.out.println(&quot;对不起，没有找到！&quot;);
        } else {
            System.out.println(&quot;在哈希表中的位置是：&quot; + result);
        }
    }
    
    /*将元素插入到哈希表中*/
    public static void insertHashTable(int[] hashTable, int target) {
        int hashAddress = hash(hashTable, target);
    
        /*如果不为0，则说明发生冲突*/
        while (hashTable[hashAddress] != 0) {
            /*利用开放定址法解决冲突，即向后寻找新地址*/
            hashAddress = (++hashAddress) % hashTable.length;
        }
    
        /*将元素插入到哈希表中*/
        hashTable[hashAddress] = target;
    }
    
    public static int searchHashTable(int[] hashTable, int target) {
        int hashAddress = hash(hashTable, target);
    
        while (hashTable[hashAddress] != target) {
            /*寻找原始地址后面的位置*/
            hashAddress = (++hashAddress) % hashTable.length;
            /*查找到开放单元(未存放元素的位置)或 循环回到原点，表示查找失败*/
            if (hashTable[hashAddress] == 0 || hashAddress == hash(hashTable, target)) {
                return -1;
            }
        }
        return hashAddress;
    }
    
    /*用除留余数法计算要插入元素的地址*/
    public static int hash(int[] hashTable, int data) {
        return data % hashTable.length;
    }
    
    public static void printHashTable(int[] hashTable) {
    	for(int i=0;i&lt;hashTable.length;i++)
    		System.out.print(hashTable[i]+&quot; &quot;);
    }

}
</code></pre>
<p><strong>测试结果：</strong></p>
<blockquote>
<p>哈希表中的数据：<br>
27 29 28 30 38 26 13<br>
要查找的数据28<br>
在哈希表中的位置是：2</p>
</blockquote>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%B8%80-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">一、顺序查找</a>
<ul>
<li><a href="#11-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">1.1 顺序查找介绍</a></li>
<li><a href="#12-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">1.2 顺序查找实现</a></li>
<li><a href="#13-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%BC%98%E5%8C%96">1.3 顺序查找优化</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二、二分查找</a>
<ul>
<li><a href="#21-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">2.1 二分查找介绍</a></li>
<li><a href="#22-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">2.2 二分查找实现</a></li>
<li><a href="#23-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93">2.3 二分查找变体</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE">三、插值查找</a>
<ul>
<li><a href="#31-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">3.1 插值查找介绍</a></li>
<li><a href="#32-%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">3.2 插值查找实现</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE">四、斐波那契查找</a>
<ul>
<li><a href="#41-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">4.1 斐波那契查找介绍</a></li>
<li><a href="#42-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">4.2 斐波那契查找实现</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE">五、树表查找</a>
<ul>
<li><a href="#51-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE">5.1 二叉树查找</a>
<ul>
<li><a href="#511-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">5.1.1 二叉排序树中序遍历</a></li>
<li><a href="#512-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">5.1.2 二叉树查找实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">六、分块查找</a>
<ul>
<li><a href="#61-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">6.1 分块查找介绍</a></li>
<li><a href="#62-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">6.2 分块查找实现</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE">七、哈希查找</a>
<ul>
<li><a href="#71-%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE%E4%BB%8B%E7%BB%8D">7.1 哈希查找介绍</a>
<ul>
<li><a href="#711-%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E8%A1%A8">7.1.1 构造哈希表</a></li>
<li><a href="#712-%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81">7.1.2 解决冲突</a></li>
</ul>
</li>
<li><a href="#72-%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0">7.2 哈希查找实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          <hr />
          
            <p class="prev-post">上一篇：
              <a href="https://tianxiawuhao.github.io/telBe8GLz/">
                <span class="post-title">
                  jenkins集成编译发布&rarr;
                </span>
              </a>
            </p>
          
          
          <p class="next-post">下一篇：
            <a href="https://tianxiawuhao.github.io/uA0v93Wq7/">
              <span class="post-title">
                git-worktree&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
    </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tianxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tianxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://tianxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>